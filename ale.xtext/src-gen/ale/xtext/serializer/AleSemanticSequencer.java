/*
 * generated by Xtext 2.10.0
 */
package ale.xtext.serializer;

import ale.xtext.ale.AddOperation;
import ale.xtext.ale.AlePackage;
import ale.xtext.ale.Block;
import ale.xtext.ale.BooleanAndOperation;
import ale.xtext.ale.BooleanLiteral;
import ale.xtext.ale.BooleanOrOperation;
import ale.xtext.ale.BooleanTypeT;
import ale.xtext.ale.BooleanXorOperation;
import ale.xtext.ale.ChainedCall;
import ale.xtext.ale.ChainedCallArrow;
import ale.xtext.ale.ClassTypeT;
import ale.xtext.ale.CompareGEOperation;
import ale.xtext.ale.CompareGOperation;
import ale.xtext.ale.CompareLEOperation;
import ale.xtext.ale.CompareLOperation;
import ale.xtext.ale.CompareNEOperation;
import ale.xtext.ale.ConstructorOperation;
import ale.xtext.ale.DefMethod;
import ale.xtext.ale.DivOperation;
import ale.xtext.ale.EqualityOperation;
import ale.xtext.ale.Field;
import ale.xtext.ale.ForLoop;
import ale.xtext.ale.IfStatement;
import ale.xtext.ale.ImpliesOperation;
import ale.xtext.ale.Import;
import ale.xtext.ale.IntLiteral;
import ale.xtext.ale.IntRange;
import ale.xtext.ale.IntTypeT;
import ale.xtext.ale.LetStatement;
import ale.xtext.ale.LiteralType;
import ale.xtext.ale.MultOperation;
import ale.xtext.ale.NegInfixOperation;
import ale.xtext.ale.NewClass;
import ale.xtext.ale.NotInfixOperation;
import ale.xtext.ale.NullLiteral;
import ale.xtext.ale.NullTypeT;
import ale.xtext.ale.OpenClass;
import ale.xtext.ale.OperationCallOperation;
import ale.xtext.ale.OrderedSetDecl;
import ale.xtext.ale.OrderedSetType;
import ale.xtext.ale.OutOfScopeType;
import ale.xtext.ale.OverrideMethod;
import ale.xtext.ale.Param;
import ale.xtext.ale.ParamCall;
import ale.xtext.ale.RealLiteral;
import ale.xtext.ale.RealTypeT;
import ale.xtext.ale.ReturnStatement;
import ale.xtext.ale.Root;
import ale.xtext.ale.SelfRef;
import ale.xtext.ale.SequenceDecl;
import ale.xtext.ale.SequenceType;
import ale.xtext.ale.SequenceTypeT;
import ale.xtext.ale.StringLiteral;
import ale.xtext.ale.StringTypeT;
import ale.xtext.ale.SubOperation;
import ale.xtext.ale.SuperRef;
import ale.xtext.ale.VarAssign;
import ale.xtext.ale.VarRef;
import ale.xtext.ale.WhileStatement;
import ale.xtext.services.AleGrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class AleSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private AleGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == AlePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case AlePackage.ADD_OPERATION:
				sequence_AddOperation(context, (AddOperation) semanticObject); 
				return; 
			case AlePackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case AlePackage.BOOLEAN_AND_OPERATION:
				sequence_BooleanOperation(context, (BooleanAndOperation) semanticObject); 
				return; 
			case AlePackage.BOOLEAN_LITERAL:
				sequence_AtomicLiteral(context, (BooleanLiteral) semanticObject); 
				return; 
			case AlePackage.BOOLEAN_OR_OPERATION:
				sequence_BooleanOperation(context, (BooleanOrOperation) semanticObject); 
				return; 
			case AlePackage.BOOLEAN_TYPE_T:
				sequence_TypeSystem(context, (BooleanTypeT) semanticObject); 
				return; 
			case AlePackage.BOOLEAN_XOR_OPERATION:
				sequence_BooleanOperation(context, (BooleanXorOperation) semanticObject); 
				return; 
			case AlePackage.CHAINED_CALL:
				sequence_ChaindedCall(context, (ChainedCall) semanticObject); 
				return; 
			case AlePackage.CHAINED_CALL_ARROW:
				sequence_ChaindedCall(context, (ChainedCallArrow) semanticObject); 
				return; 
			case AlePackage.CLASS_TYPE_T:
				sequence_TypeSystem(context, (ClassTypeT) semanticObject); 
				return; 
			case AlePackage.COMPARE_GE_OPERATION:
				sequence_CompareOperation(context, (CompareGEOperation) semanticObject); 
				return; 
			case AlePackage.COMPARE_GOPERATION:
				sequence_CompareOperation(context, (CompareGOperation) semanticObject); 
				return; 
			case AlePackage.COMPARE_LE_OPERATION:
				sequence_CompareOperation(context, (CompareLEOperation) semanticObject); 
				return; 
			case AlePackage.COMPARE_LOPERATION:
				sequence_CompareOperation(context, (CompareLOperation) semanticObject); 
				return; 
			case AlePackage.COMPARE_NE_OPERATION:
				sequence_CompareOperation(context, (CompareNEOperation) semanticObject); 
				return; 
			case AlePackage.CONSTRUCTOR_OPERATION:
				sequence_InfixOperation(context, (ConstructorOperation) semanticObject); 
				return; 
			case AlePackage.DEF_METHOD:
				sequence_DefMethod(context, (DefMethod) semanticObject); 
				return; 
			case AlePackage.DIV_OPERATION:
				sequence_MultOperation(context, (DivOperation) semanticObject); 
				return; 
			case AlePackage.EQUALITY_OPERATION:
				sequence_EqualityOperation(context, (EqualityOperation) semanticObject); 
				return; 
			case AlePackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case AlePackage.FOR_LOOP:
				sequence_ForLoop(context, (ForLoop) semanticObject); 
				return; 
			case AlePackage.IF_STATEMENT:
				sequence_IfStatement(context, (IfStatement) semanticObject); 
				return; 
			case AlePackage.IMPLIES_OPERATION:
				sequence_ImpliesOperation(context, (ImpliesOperation) semanticObject); 
				return; 
			case AlePackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case AlePackage.INT_LITERAL:
				sequence_AtomicLiteral(context, (IntLiteral) semanticObject); 
				return; 
			case AlePackage.INT_RANGE:
				sequence_AtomicLiteral(context, (IntRange) semanticObject); 
				return; 
			case AlePackage.INT_TYPE_T:
				sequence_TypeSystem(context, (IntTypeT) semanticObject); 
				return; 
			case AlePackage.LET_STATEMENT:
				sequence_LetStatement(context, (LetStatement) semanticObject); 
				return; 
			case AlePackage.LITERAL_TYPE:
				sequence_LiteralType(context, (LiteralType) semanticObject); 
				return; 
			case AlePackage.MULT_OPERATION:
				sequence_MultOperation(context, (MultOperation) semanticObject); 
				return; 
			case AlePackage.NEG_INFIX_OPERATION:
				sequence_InfixOperation(context, (NegInfixOperation) semanticObject); 
				return; 
			case AlePackage.NEW_CLASS:
				sequence_NewClass(context, (NewClass) semanticObject); 
				return; 
			case AlePackage.NOT_INFIX_OPERATION:
				sequence_InfixOperation(context, (NotInfixOperation) semanticObject); 
				return; 
			case AlePackage.NULL_LITERAL:
				sequence_AtomicLiteral(context, (NullLiteral) semanticObject); 
				return; 
			case AlePackage.NULL_TYPE_T:
				sequence_TypeSystem(context, (NullTypeT) semanticObject); 
				return; 
			case AlePackage.OPEN_CLASS:
				sequence_OpenClass(context, (OpenClass) semanticObject); 
				return; 
			case AlePackage.OPERATION_CALL_OPERATION:
				sequence_InfixOperation(context, (OperationCallOperation) semanticObject); 
				return; 
			case AlePackage.ORDERED_SET_DECL:
				sequence_AtomicLiteral(context, (OrderedSetDecl) semanticObject); 
				return; 
			case AlePackage.ORDERED_SET_TYPE:
				sequence_Type(context, (OrderedSetType) semanticObject); 
				return; 
			case AlePackage.OUT_OF_SCOPE_TYPE:
				sequence_Type(context, (OutOfScopeType) semanticObject); 
				return; 
			case AlePackage.OVERRIDE_METHOD:
				sequence_OverrideMethod(context, (OverrideMethod) semanticObject); 
				return; 
			case AlePackage.PARAM:
				sequence_Param(context, (Param) semanticObject); 
				return; 
			case AlePackage.PARAM_CALL:
				sequence_ParamCall(context, (ParamCall) semanticObject); 
				return; 
			case AlePackage.REAL_LITERAL:
				sequence_AtomicLiteral(context, (RealLiteral) semanticObject); 
				return; 
			case AlePackage.REAL_TYPE_T:
				sequence_TypeSystem(context, (RealTypeT) semanticObject); 
				return; 
			case AlePackage.RETURN_STATEMENT:
				sequence_ReturnStatement(context, (ReturnStatement) semanticObject); 
				return; 
			case AlePackage.ROOT:
				sequence_Root(context, (Root) semanticObject); 
				return; 
			case AlePackage.SELF_REF:
				sequence_AtomicLiteral(context, (SelfRef) semanticObject); 
				return; 
			case AlePackage.SEQUENCE_DECL:
				sequence_AtomicLiteral(context, (SequenceDecl) semanticObject); 
				return; 
			case AlePackage.SEQUENCE_TYPE:
				sequence_Type(context, (SequenceType) semanticObject); 
				return; 
			case AlePackage.SEQUENCE_TYPE_T:
				sequence_TypeSystem(context, (SequenceTypeT) semanticObject); 
				return; 
			case AlePackage.STRING_LITERAL:
				sequence_AtomicLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case AlePackage.STRING_TYPE_T:
				sequence_TypeSystem(context, (StringTypeT) semanticObject); 
				return; 
			case AlePackage.SUB_OPERATION:
				sequence_AddOperation(context, (SubOperation) semanticObject); 
				return; 
			case AlePackage.SUPER_REF:
				sequence_AtomicLiteral(context, (SuperRef) semanticObject); 
				return; 
			case AlePackage.VAR_ASSIGN:
				sequence_VarAssign(context, (VarAssign) semanticObject); 
				return; 
			case AlePackage.VAR_REF:
				sequence_AtomicLiteral(context, (VarRef) semanticObject); 
				return; 
			case AlePackage.WHILE_STATEMENT:
				sequence_WhileStatement(context, (WhileStatement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Statement returns AddOperation
	 *     Expression returns AddOperation
	 *     ImpliesOperation returns AddOperation
	 *     ImpliesOperation.ImpliesOperation_1_0_0_0 returns AddOperation
	 *     BooleanOperation returns AddOperation
	 *     BooleanOperation.BooleanOrOperation_1_0_0_0_0 returns AddOperation
	 *     BooleanOperation.BooleanAndOperation_1_0_0_1_0 returns AddOperation
	 *     BooleanOperation.BooleanXorOperation_1_0_0_2_0 returns AddOperation
	 *     CompareOperation returns AddOperation
	 *     CompareOperation.CompareLEOperation_1_0_0_0_0 returns AddOperation
	 *     CompareOperation.CompareGEOperation_1_0_0_1_0 returns AddOperation
	 *     CompareOperation.CompareNEOperation_1_0_0_2_0 returns AddOperation
	 *     CompareOperation.CompareLOperation_1_0_0_3_0 returns AddOperation
	 *     CompareOperation.CompareGOperation_1_0_0_4_0 returns AddOperation
	 *     EqualityOperation returns AddOperation
	 *     EqualityOperation.EqualityOperation_1_0_0 returns AddOperation
	 *     MultOperation returns AddOperation
	 *     MultOperation.MultOperation_1_0_0_0_0 returns AddOperation
	 *     MultOperation.DivOperation_1_0_0_1_0 returns AddOperation
	 *     AddOperation returns AddOperation
	 *     AddOperation.AddOperation_1_0_0_0_0 returns AddOperation
	 *     AddOperation.SubOperation_1_0_0_1_0 returns AddOperation
	 *     ChaindedCall returns AddOperation
	 *     ChaindedCall.ChainedCall_1_0_0_0_0 returns AddOperation
	 *     ChaindedCall.ChainedCallArrow_1_0_0_1_0 returns AddOperation
	 *     InfixOperation returns AddOperation
	 *     AtomicLiteral returns AddOperation
	 *
	 * Constraint:
	 *     (left=AddOperation_AddOperation_1_0_0_0_0 right=ChaindedCall)
	 */
	protected void sequence_AddOperation(ISerializationContext context, AddOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.ADD_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.ADD_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.ADD_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.ADD_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAddOperationAccess().getAddOperationLeftAction_1_0_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAddOperationAccess().getRightChaindedCallParserRuleCall_1_0_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SubOperation
	 *     Expression returns SubOperation
	 *     ImpliesOperation returns SubOperation
	 *     ImpliesOperation.ImpliesOperation_1_0_0_0 returns SubOperation
	 *     BooleanOperation returns SubOperation
	 *     BooleanOperation.BooleanOrOperation_1_0_0_0_0 returns SubOperation
	 *     BooleanOperation.BooleanAndOperation_1_0_0_1_0 returns SubOperation
	 *     BooleanOperation.BooleanXorOperation_1_0_0_2_0 returns SubOperation
	 *     CompareOperation returns SubOperation
	 *     CompareOperation.CompareLEOperation_1_0_0_0_0 returns SubOperation
	 *     CompareOperation.CompareGEOperation_1_0_0_1_0 returns SubOperation
	 *     CompareOperation.CompareNEOperation_1_0_0_2_0 returns SubOperation
	 *     CompareOperation.CompareLOperation_1_0_0_3_0 returns SubOperation
	 *     CompareOperation.CompareGOperation_1_0_0_4_0 returns SubOperation
	 *     EqualityOperation returns SubOperation
	 *     EqualityOperation.EqualityOperation_1_0_0 returns SubOperation
	 *     MultOperation returns SubOperation
	 *     MultOperation.MultOperation_1_0_0_0_0 returns SubOperation
	 *     MultOperation.DivOperation_1_0_0_1_0 returns SubOperation
	 *     AddOperation returns SubOperation
	 *     AddOperation.AddOperation_1_0_0_0_0 returns SubOperation
	 *     AddOperation.SubOperation_1_0_0_1_0 returns SubOperation
	 *     ChaindedCall returns SubOperation
	 *     ChaindedCall.ChainedCall_1_0_0_0_0 returns SubOperation
	 *     ChaindedCall.ChainedCallArrow_1_0_0_1_0 returns SubOperation
	 *     InfixOperation returns SubOperation
	 *     AtomicLiteral returns SubOperation
	 *
	 * Constraint:
	 *     (left=AddOperation_SubOperation_1_0_0_1_0 right=ChaindedCall)
	 */
	protected void sequence_AddOperation(ISerializationContext context, SubOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.SUB_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.SUB_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.SUB_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.SUB_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAddOperationAccess().getSubOperationLeftAction_1_0_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAddOperationAccess().getRightChaindedCallParserRuleCall_1_0_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns BooleanLiteral
	 *     Expression returns BooleanLiteral
	 *     ImpliesOperation returns BooleanLiteral
	 *     ImpliesOperation.ImpliesOperation_1_0_0_0 returns BooleanLiteral
	 *     BooleanOperation returns BooleanLiteral
	 *     BooleanOperation.BooleanOrOperation_1_0_0_0_0 returns BooleanLiteral
	 *     BooleanOperation.BooleanAndOperation_1_0_0_1_0 returns BooleanLiteral
	 *     BooleanOperation.BooleanXorOperation_1_0_0_2_0 returns BooleanLiteral
	 *     CompareOperation returns BooleanLiteral
	 *     CompareOperation.CompareLEOperation_1_0_0_0_0 returns BooleanLiteral
	 *     CompareOperation.CompareGEOperation_1_0_0_1_0 returns BooleanLiteral
	 *     CompareOperation.CompareNEOperation_1_0_0_2_0 returns BooleanLiteral
	 *     CompareOperation.CompareLOperation_1_0_0_3_0 returns BooleanLiteral
	 *     CompareOperation.CompareGOperation_1_0_0_4_0 returns BooleanLiteral
	 *     EqualityOperation returns BooleanLiteral
	 *     EqualityOperation.EqualityOperation_1_0_0 returns BooleanLiteral
	 *     MultOperation returns BooleanLiteral
	 *     MultOperation.MultOperation_1_0_0_0_0 returns BooleanLiteral
	 *     MultOperation.DivOperation_1_0_0_1_0 returns BooleanLiteral
	 *     AddOperation returns BooleanLiteral
	 *     AddOperation.AddOperation_1_0_0_0_0 returns BooleanLiteral
	 *     AddOperation.SubOperation_1_0_0_1_0 returns BooleanLiteral
	 *     ChaindedCall returns BooleanLiteral
	 *     ChaindedCall.ChainedCall_1_0_0_0_0 returns BooleanLiteral
	 *     ChaindedCall.ChainedCallArrow_1_0_0_1_0 returns BooleanLiteral
	 *     InfixOperation returns BooleanLiteral
	 *     AtomicLiteral returns BooleanLiteral
	 *
	 * Constraint:
	 *     value=BOOLEAN
	 */
	protected void sequence_AtomicLiteral(ISerializationContext context, BooleanLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.BOOLEAN_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.BOOLEAN_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicLiteralAccess().getValueBOOLEANTerminalRuleCall_6_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IntLiteral
	 *     Expression returns IntLiteral
	 *     ImpliesOperation returns IntLiteral
	 *     ImpliesOperation.ImpliesOperation_1_0_0_0 returns IntLiteral
	 *     BooleanOperation returns IntLiteral
	 *     BooleanOperation.BooleanOrOperation_1_0_0_0_0 returns IntLiteral
	 *     BooleanOperation.BooleanAndOperation_1_0_0_1_0 returns IntLiteral
	 *     BooleanOperation.BooleanXorOperation_1_0_0_2_0 returns IntLiteral
	 *     CompareOperation returns IntLiteral
	 *     CompareOperation.CompareLEOperation_1_0_0_0_0 returns IntLiteral
	 *     CompareOperation.CompareGEOperation_1_0_0_1_0 returns IntLiteral
	 *     CompareOperation.CompareNEOperation_1_0_0_2_0 returns IntLiteral
	 *     CompareOperation.CompareLOperation_1_0_0_3_0 returns IntLiteral
	 *     CompareOperation.CompareGOperation_1_0_0_4_0 returns IntLiteral
	 *     EqualityOperation returns IntLiteral
	 *     EqualityOperation.EqualityOperation_1_0_0 returns IntLiteral
	 *     MultOperation returns IntLiteral
	 *     MultOperation.MultOperation_1_0_0_0_0 returns IntLiteral
	 *     MultOperation.DivOperation_1_0_0_1_0 returns IntLiteral
	 *     AddOperation returns IntLiteral
	 *     AddOperation.AddOperation_1_0_0_0_0 returns IntLiteral
	 *     AddOperation.SubOperation_1_0_0_1_0 returns IntLiteral
	 *     ChaindedCall returns IntLiteral
	 *     ChaindedCall.ChainedCall_1_0_0_0_0 returns IntLiteral
	 *     ChaindedCall.ChainedCallArrow_1_0_0_1_0 returns IntLiteral
	 *     InfixOperation returns IntLiteral
	 *     AtomicLiteral returns IntLiteral
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_AtomicLiteral(ISerializationContext context, IntLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.INT_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.INT_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicLiteralAccess().getValueINTTerminalRuleCall_4_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IntRange
	 *     Expression returns IntRange
	 *     ImpliesOperation returns IntRange
	 *     ImpliesOperation.ImpliesOperation_1_0_0_0 returns IntRange
	 *     BooleanOperation returns IntRange
	 *     BooleanOperation.BooleanOrOperation_1_0_0_0_0 returns IntRange
	 *     BooleanOperation.BooleanAndOperation_1_0_0_1_0 returns IntRange
	 *     BooleanOperation.BooleanXorOperation_1_0_0_2_0 returns IntRange
	 *     CompareOperation returns IntRange
	 *     CompareOperation.CompareLEOperation_1_0_0_0_0 returns IntRange
	 *     CompareOperation.CompareGEOperation_1_0_0_1_0 returns IntRange
	 *     CompareOperation.CompareNEOperation_1_0_0_2_0 returns IntRange
	 *     CompareOperation.CompareLOperation_1_0_0_3_0 returns IntRange
	 *     CompareOperation.CompareGOperation_1_0_0_4_0 returns IntRange
	 *     EqualityOperation returns IntRange
	 *     EqualityOperation.EqualityOperation_1_0_0 returns IntRange
	 *     MultOperation returns IntRange
	 *     MultOperation.MultOperation_1_0_0_0_0 returns IntRange
	 *     MultOperation.DivOperation_1_0_0_1_0 returns IntRange
	 *     AddOperation returns IntRange
	 *     AddOperation.AddOperation_1_0_0_0_0 returns IntRange
	 *     AddOperation.SubOperation_1_0_0_1_0 returns IntRange
	 *     ChaindedCall returns IntRange
	 *     ChaindedCall.ChainedCall_1_0_0_0_0 returns IntRange
	 *     ChaindedCall.ChainedCallArrow_1_0_0_1_0 returns IntRange
	 *     InfixOperation returns IntRange
	 *     AtomicLiteral returns IntRange
	 *
	 * Constraint:
	 *     (start=Expression stop=Expression)
	 */
	protected void sequence_AtomicLiteral(ISerializationContext context, IntRange semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.INT_RANGE__START) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.INT_RANGE__START));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.INT_RANGE__STOP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.INT_RANGE__STOP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicLiteralAccess().getStartExpressionParserRuleCall_8_2_0(), semanticObject.getStart());
		feeder.accept(grammarAccess.getAtomicLiteralAccess().getStopExpressionParserRuleCall_8_5_0(), semanticObject.getStop());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns NullLiteral
	 *     Expression returns NullLiteral
	 *     ImpliesOperation returns NullLiteral
	 *     ImpliesOperation.ImpliesOperation_1_0_0_0 returns NullLiteral
	 *     BooleanOperation returns NullLiteral
	 *     BooleanOperation.BooleanOrOperation_1_0_0_0_0 returns NullLiteral
	 *     BooleanOperation.BooleanAndOperation_1_0_0_1_0 returns NullLiteral
	 *     BooleanOperation.BooleanXorOperation_1_0_0_2_0 returns NullLiteral
	 *     CompareOperation returns NullLiteral
	 *     CompareOperation.CompareLEOperation_1_0_0_0_0 returns NullLiteral
	 *     CompareOperation.CompareGEOperation_1_0_0_1_0 returns NullLiteral
	 *     CompareOperation.CompareNEOperation_1_0_0_2_0 returns NullLiteral
	 *     CompareOperation.CompareLOperation_1_0_0_3_0 returns NullLiteral
	 *     CompareOperation.CompareGOperation_1_0_0_4_0 returns NullLiteral
	 *     EqualityOperation returns NullLiteral
	 *     EqualityOperation.EqualityOperation_1_0_0 returns NullLiteral
	 *     MultOperation returns NullLiteral
	 *     MultOperation.MultOperation_1_0_0_0_0 returns NullLiteral
	 *     MultOperation.DivOperation_1_0_0_1_0 returns NullLiteral
	 *     AddOperation returns NullLiteral
	 *     AddOperation.AddOperation_1_0_0_0_0 returns NullLiteral
	 *     AddOperation.SubOperation_1_0_0_1_0 returns NullLiteral
	 *     ChaindedCall returns NullLiteral
	 *     ChaindedCall.ChainedCall_1_0_0_0_0 returns NullLiteral
	 *     ChaindedCall.ChainedCallArrow_1_0_0_1_0 returns NullLiteral
	 *     InfixOperation returns NullLiteral
	 *     AtomicLiteral returns NullLiteral
	 *
	 * Constraint:
	 *     {NullLiteral}
	 */
	protected void sequence_AtomicLiteral(ISerializationContext context, NullLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns OrderedSetDecl
	 *     Expression returns OrderedSetDecl
	 *     ImpliesOperation returns OrderedSetDecl
	 *     ImpliesOperation.ImpliesOperation_1_0_0_0 returns OrderedSetDecl
	 *     BooleanOperation returns OrderedSetDecl
	 *     BooleanOperation.BooleanOrOperation_1_0_0_0_0 returns OrderedSetDecl
	 *     BooleanOperation.BooleanAndOperation_1_0_0_1_0 returns OrderedSetDecl
	 *     BooleanOperation.BooleanXorOperation_1_0_0_2_0 returns OrderedSetDecl
	 *     CompareOperation returns OrderedSetDecl
	 *     CompareOperation.CompareLEOperation_1_0_0_0_0 returns OrderedSetDecl
	 *     CompareOperation.CompareGEOperation_1_0_0_1_0 returns OrderedSetDecl
	 *     CompareOperation.CompareNEOperation_1_0_0_2_0 returns OrderedSetDecl
	 *     CompareOperation.CompareLOperation_1_0_0_3_0 returns OrderedSetDecl
	 *     CompareOperation.CompareGOperation_1_0_0_4_0 returns OrderedSetDecl
	 *     EqualityOperation returns OrderedSetDecl
	 *     EqualityOperation.EqualityOperation_1_0_0 returns OrderedSetDecl
	 *     MultOperation returns OrderedSetDecl
	 *     MultOperation.MultOperation_1_0_0_0_0 returns OrderedSetDecl
	 *     MultOperation.DivOperation_1_0_0_1_0 returns OrderedSetDecl
	 *     AddOperation returns OrderedSetDecl
	 *     AddOperation.AddOperation_1_0_0_0_0 returns OrderedSetDecl
	 *     AddOperation.SubOperation_1_0_0_1_0 returns OrderedSetDecl
	 *     ChaindedCall returns OrderedSetDecl
	 *     ChaindedCall.ChainedCall_1_0_0_0_0 returns OrderedSetDecl
	 *     ChaindedCall.ChainedCallArrow_1_0_0_1_0 returns OrderedSetDecl
	 *     InfixOperation returns OrderedSetDecl
	 *     AtomicLiteral returns OrderedSetDecl
	 *
	 * Constraint:
	 *     (expressions+=Expression expressions+=Expression*)?
	 */
	protected void sequence_AtomicLiteral(ISerializationContext context, OrderedSetDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns RealLiteral
	 *     Expression returns RealLiteral
	 *     ImpliesOperation returns RealLiteral
	 *     ImpliesOperation.ImpliesOperation_1_0_0_0 returns RealLiteral
	 *     BooleanOperation returns RealLiteral
	 *     BooleanOperation.BooleanOrOperation_1_0_0_0_0 returns RealLiteral
	 *     BooleanOperation.BooleanAndOperation_1_0_0_1_0 returns RealLiteral
	 *     BooleanOperation.BooleanXorOperation_1_0_0_2_0 returns RealLiteral
	 *     CompareOperation returns RealLiteral
	 *     CompareOperation.CompareLEOperation_1_0_0_0_0 returns RealLiteral
	 *     CompareOperation.CompareGEOperation_1_0_0_1_0 returns RealLiteral
	 *     CompareOperation.CompareNEOperation_1_0_0_2_0 returns RealLiteral
	 *     CompareOperation.CompareLOperation_1_0_0_3_0 returns RealLiteral
	 *     CompareOperation.CompareGOperation_1_0_0_4_0 returns RealLiteral
	 *     EqualityOperation returns RealLiteral
	 *     EqualityOperation.EqualityOperation_1_0_0 returns RealLiteral
	 *     MultOperation returns RealLiteral
	 *     MultOperation.MultOperation_1_0_0_0_0 returns RealLiteral
	 *     MultOperation.DivOperation_1_0_0_1_0 returns RealLiteral
	 *     AddOperation returns RealLiteral
	 *     AddOperation.AddOperation_1_0_0_0_0 returns RealLiteral
	 *     AddOperation.SubOperation_1_0_0_1_0 returns RealLiteral
	 *     ChaindedCall returns RealLiteral
	 *     ChaindedCall.ChainedCall_1_0_0_0_0 returns RealLiteral
	 *     ChaindedCall.ChainedCallArrow_1_0_0_1_0 returns RealLiteral
	 *     InfixOperation returns RealLiteral
	 *     AtomicLiteral returns RealLiteral
	 *
	 * Constraint:
	 *     value=REAL
	 */
	protected void sequence_AtomicLiteral(ISerializationContext context, RealLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.REAL_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.REAL_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicLiteralAccess().getValueREALTerminalRuleCall_5_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SelfRef
	 *     Expression returns SelfRef
	 *     ImpliesOperation returns SelfRef
	 *     ImpliesOperation.ImpliesOperation_1_0_0_0 returns SelfRef
	 *     BooleanOperation returns SelfRef
	 *     BooleanOperation.BooleanOrOperation_1_0_0_0_0 returns SelfRef
	 *     BooleanOperation.BooleanAndOperation_1_0_0_1_0 returns SelfRef
	 *     BooleanOperation.BooleanXorOperation_1_0_0_2_0 returns SelfRef
	 *     CompareOperation returns SelfRef
	 *     CompareOperation.CompareLEOperation_1_0_0_0_0 returns SelfRef
	 *     CompareOperation.CompareGEOperation_1_0_0_1_0 returns SelfRef
	 *     CompareOperation.CompareNEOperation_1_0_0_2_0 returns SelfRef
	 *     CompareOperation.CompareLOperation_1_0_0_3_0 returns SelfRef
	 *     CompareOperation.CompareGOperation_1_0_0_4_0 returns SelfRef
	 *     EqualityOperation returns SelfRef
	 *     EqualityOperation.EqualityOperation_1_0_0 returns SelfRef
	 *     MultOperation returns SelfRef
	 *     MultOperation.MultOperation_1_0_0_0_0 returns SelfRef
	 *     MultOperation.DivOperation_1_0_0_1_0 returns SelfRef
	 *     AddOperation returns SelfRef
	 *     AddOperation.AddOperation_1_0_0_0_0 returns SelfRef
	 *     AddOperation.SubOperation_1_0_0_1_0 returns SelfRef
	 *     ChaindedCall returns SelfRef
	 *     ChaindedCall.ChainedCall_1_0_0_0_0 returns SelfRef
	 *     ChaindedCall.ChainedCallArrow_1_0_0_1_0 returns SelfRef
	 *     InfixOperation returns SelfRef
	 *     AtomicLiteral returns SelfRef
	 *
	 * Constraint:
	 *     {SelfRef}
	 */
	protected void sequence_AtomicLiteral(ISerializationContext context, SelfRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SequenceDecl
	 *     Expression returns SequenceDecl
	 *     ImpliesOperation returns SequenceDecl
	 *     ImpliesOperation.ImpliesOperation_1_0_0_0 returns SequenceDecl
	 *     BooleanOperation returns SequenceDecl
	 *     BooleanOperation.BooleanOrOperation_1_0_0_0_0 returns SequenceDecl
	 *     BooleanOperation.BooleanAndOperation_1_0_0_1_0 returns SequenceDecl
	 *     BooleanOperation.BooleanXorOperation_1_0_0_2_0 returns SequenceDecl
	 *     CompareOperation returns SequenceDecl
	 *     CompareOperation.CompareLEOperation_1_0_0_0_0 returns SequenceDecl
	 *     CompareOperation.CompareGEOperation_1_0_0_1_0 returns SequenceDecl
	 *     CompareOperation.CompareNEOperation_1_0_0_2_0 returns SequenceDecl
	 *     CompareOperation.CompareLOperation_1_0_0_3_0 returns SequenceDecl
	 *     CompareOperation.CompareGOperation_1_0_0_4_0 returns SequenceDecl
	 *     EqualityOperation returns SequenceDecl
	 *     EqualityOperation.EqualityOperation_1_0_0 returns SequenceDecl
	 *     MultOperation returns SequenceDecl
	 *     MultOperation.MultOperation_1_0_0_0_0 returns SequenceDecl
	 *     MultOperation.DivOperation_1_0_0_1_0 returns SequenceDecl
	 *     AddOperation returns SequenceDecl
	 *     AddOperation.AddOperation_1_0_0_0_0 returns SequenceDecl
	 *     AddOperation.SubOperation_1_0_0_1_0 returns SequenceDecl
	 *     ChaindedCall returns SequenceDecl
	 *     ChaindedCall.ChainedCall_1_0_0_0_0 returns SequenceDecl
	 *     ChaindedCall.ChainedCallArrow_1_0_0_1_0 returns SequenceDecl
	 *     InfixOperation returns SequenceDecl
	 *     AtomicLiteral returns SequenceDecl
	 *
	 * Constraint:
	 *     (expressions+=Expression expressions+=Expression*)?
	 */
	protected void sequence_AtomicLiteral(ISerializationContext context, SequenceDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns StringLiteral
	 *     Expression returns StringLiteral
	 *     ImpliesOperation returns StringLiteral
	 *     ImpliesOperation.ImpliesOperation_1_0_0_0 returns StringLiteral
	 *     BooleanOperation returns StringLiteral
	 *     BooleanOperation.BooleanOrOperation_1_0_0_0_0 returns StringLiteral
	 *     BooleanOperation.BooleanAndOperation_1_0_0_1_0 returns StringLiteral
	 *     BooleanOperation.BooleanXorOperation_1_0_0_2_0 returns StringLiteral
	 *     CompareOperation returns StringLiteral
	 *     CompareOperation.CompareLEOperation_1_0_0_0_0 returns StringLiteral
	 *     CompareOperation.CompareGEOperation_1_0_0_1_0 returns StringLiteral
	 *     CompareOperation.CompareNEOperation_1_0_0_2_0 returns StringLiteral
	 *     CompareOperation.CompareLOperation_1_0_0_3_0 returns StringLiteral
	 *     CompareOperation.CompareGOperation_1_0_0_4_0 returns StringLiteral
	 *     EqualityOperation returns StringLiteral
	 *     EqualityOperation.EqualityOperation_1_0_0 returns StringLiteral
	 *     MultOperation returns StringLiteral
	 *     MultOperation.MultOperation_1_0_0_0_0 returns StringLiteral
	 *     MultOperation.DivOperation_1_0_0_1_0 returns StringLiteral
	 *     AddOperation returns StringLiteral
	 *     AddOperation.AddOperation_1_0_0_0_0 returns StringLiteral
	 *     AddOperation.SubOperation_1_0_0_1_0 returns StringLiteral
	 *     ChaindedCall returns StringLiteral
	 *     ChaindedCall.ChainedCall_1_0_0_0_0 returns StringLiteral
	 *     ChaindedCall.ChainedCallArrow_1_0_0_1_0 returns StringLiteral
	 *     InfixOperation returns StringLiteral
	 *     AtomicLiteral returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_AtomicLiteral(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicLiteralAccess().getValueSTRINGTerminalRuleCall_3_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SuperRef
	 *     Expression returns SuperRef
	 *     ImpliesOperation returns SuperRef
	 *     ImpliesOperation.ImpliesOperation_1_0_0_0 returns SuperRef
	 *     BooleanOperation returns SuperRef
	 *     BooleanOperation.BooleanOrOperation_1_0_0_0_0 returns SuperRef
	 *     BooleanOperation.BooleanAndOperation_1_0_0_1_0 returns SuperRef
	 *     BooleanOperation.BooleanXorOperation_1_0_0_2_0 returns SuperRef
	 *     CompareOperation returns SuperRef
	 *     CompareOperation.CompareLEOperation_1_0_0_0_0 returns SuperRef
	 *     CompareOperation.CompareGEOperation_1_0_0_1_0 returns SuperRef
	 *     CompareOperation.CompareNEOperation_1_0_0_2_0 returns SuperRef
	 *     CompareOperation.CompareLOperation_1_0_0_3_0 returns SuperRef
	 *     CompareOperation.CompareGOperation_1_0_0_4_0 returns SuperRef
	 *     EqualityOperation returns SuperRef
	 *     EqualityOperation.EqualityOperation_1_0_0 returns SuperRef
	 *     MultOperation returns SuperRef
	 *     MultOperation.MultOperation_1_0_0_0_0 returns SuperRef
	 *     MultOperation.DivOperation_1_0_0_1_0 returns SuperRef
	 *     AddOperation returns SuperRef
	 *     AddOperation.AddOperation_1_0_0_0_0 returns SuperRef
	 *     AddOperation.SubOperation_1_0_0_1_0 returns SuperRef
	 *     ChaindedCall returns SuperRef
	 *     ChaindedCall.ChainedCall_1_0_0_0_0 returns SuperRef
	 *     ChaindedCall.ChainedCallArrow_1_0_0_1_0 returns SuperRef
	 *     InfixOperation returns SuperRef
	 *     AtomicLiteral returns SuperRef
	 *
	 * Constraint:
	 *     {SuperRef}
	 */
	protected void sequence_AtomicLiteral(ISerializationContext context, SuperRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns VarRef
	 *     Expression returns VarRef
	 *     ImpliesOperation returns VarRef
	 *     ImpliesOperation.ImpliesOperation_1_0_0_0 returns VarRef
	 *     BooleanOperation returns VarRef
	 *     BooleanOperation.BooleanOrOperation_1_0_0_0_0 returns VarRef
	 *     BooleanOperation.BooleanAndOperation_1_0_0_1_0 returns VarRef
	 *     BooleanOperation.BooleanXorOperation_1_0_0_2_0 returns VarRef
	 *     CompareOperation returns VarRef
	 *     CompareOperation.CompareLEOperation_1_0_0_0_0 returns VarRef
	 *     CompareOperation.CompareGEOperation_1_0_0_1_0 returns VarRef
	 *     CompareOperation.CompareNEOperation_1_0_0_2_0 returns VarRef
	 *     CompareOperation.CompareLOperation_1_0_0_3_0 returns VarRef
	 *     CompareOperation.CompareGOperation_1_0_0_4_0 returns VarRef
	 *     EqualityOperation returns VarRef
	 *     EqualityOperation.EqualityOperation_1_0_0 returns VarRef
	 *     MultOperation returns VarRef
	 *     MultOperation.MultOperation_1_0_0_0_0 returns VarRef
	 *     MultOperation.DivOperation_1_0_0_1_0 returns VarRef
	 *     AddOperation returns VarRef
	 *     AddOperation.AddOperation_1_0_0_0_0 returns VarRef
	 *     AddOperation.SubOperation_1_0_0_1_0 returns VarRef
	 *     ChaindedCall returns VarRef
	 *     ChaindedCall.ChainedCall_1_0_0_0_0 returns VarRef
	 *     ChaindedCall.ChainedCallArrow_1_0_0_1_0 returns VarRef
	 *     InfixOperation returns VarRef
	 *     AtomicLiteral returns VarRef
	 *
	 * Constraint:
	 *     value=ID
	 */
	protected void sequence_AtomicLiteral(ISerializationContext context, VarRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.VAR_REF__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.VAR_REF__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicLiteralAccess().getValueIDTerminalRuleCall_11_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Block returns Block
	 *
	 * Constraint:
	 *     body+=Statement*
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns BooleanAndOperation
	 *     Expression returns BooleanAndOperation
	 *     ImpliesOperation returns BooleanAndOperation
	 *     ImpliesOperation.ImpliesOperation_1_0_0_0 returns BooleanAndOperation
	 *     BooleanOperation returns BooleanAndOperation
	 *     BooleanOperation.BooleanOrOperation_1_0_0_0_0 returns BooleanAndOperation
	 *     BooleanOperation.BooleanAndOperation_1_0_0_1_0 returns BooleanAndOperation
	 *     BooleanOperation.BooleanXorOperation_1_0_0_2_0 returns BooleanAndOperation
	 *     CompareOperation returns BooleanAndOperation
	 *     CompareOperation.CompareLEOperation_1_0_0_0_0 returns BooleanAndOperation
	 *     CompareOperation.CompareGEOperation_1_0_0_1_0 returns BooleanAndOperation
	 *     CompareOperation.CompareNEOperation_1_0_0_2_0 returns BooleanAndOperation
	 *     CompareOperation.CompareLOperation_1_0_0_3_0 returns BooleanAndOperation
	 *     CompareOperation.CompareGOperation_1_0_0_4_0 returns BooleanAndOperation
	 *     EqualityOperation returns BooleanAndOperation
	 *     EqualityOperation.EqualityOperation_1_0_0 returns BooleanAndOperation
	 *     MultOperation returns BooleanAndOperation
	 *     MultOperation.MultOperation_1_0_0_0_0 returns BooleanAndOperation
	 *     MultOperation.DivOperation_1_0_0_1_0 returns BooleanAndOperation
	 *     AddOperation returns BooleanAndOperation
	 *     AddOperation.AddOperation_1_0_0_0_0 returns BooleanAndOperation
	 *     AddOperation.SubOperation_1_0_0_1_0 returns BooleanAndOperation
	 *     ChaindedCall returns BooleanAndOperation
	 *     ChaindedCall.ChainedCall_1_0_0_0_0 returns BooleanAndOperation
	 *     ChaindedCall.ChainedCallArrow_1_0_0_1_0 returns BooleanAndOperation
	 *     InfixOperation returns BooleanAndOperation
	 *     AtomicLiteral returns BooleanAndOperation
	 *
	 * Constraint:
	 *     (left=BooleanOperation_BooleanAndOperation_1_0_0_1_0 right=CompareOperation)
	 */
	protected void sequence_BooleanOperation(ISerializationContext context, BooleanAndOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.BOOLEAN_AND_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.BOOLEAN_AND_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.BOOLEAN_AND_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.BOOLEAN_AND_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanOperationAccess().getBooleanAndOperationLeftAction_1_0_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBooleanOperationAccess().getRightCompareOperationParserRuleCall_1_0_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns BooleanOrOperation
	 *     Expression returns BooleanOrOperation
	 *     ImpliesOperation returns BooleanOrOperation
	 *     ImpliesOperation.ImpliesOperation_1_0_0_0 returns BooleanOrOperation
	 *     BooleanOperation returns BooleanOrOperation
	 *     BooleanOperation.BooleanOrOperation_1_0_0_0_0 returns BooleanOrOperation
	 *     BooleanOperation.BooleanAndOperation_1_0_0_1_0 returns BooleanOrOperation
	 *     BooleanOperation.BooleanXorOperation_1_0_0_2_0 returns BooleanOrOperation
	 *     CompareOperation returns BooleanOrOperation
	 *     CompareOperation.CompareLEOperation_1_0_0_0_0 returns BooleanOrOperation
	 *     CompareOperation.CompareGEOperation_1_0_0_1_0 returns BooleanOrOperation
	 *     CompareOperation.CompareNEOperation_1_0_0_2_0 returns BooleanOrOperation
	 *     CompareOperation.CompareLOperation_1_0_0_3_0 returns BooleanOrOperation
	 *     CompareOperation.CompareGOperation_1_0_0_4_0 returns BooleanOrOperation
	 *     EqualityOperation returns BooleanOrOperation
	 *     EqualityOperation.EqualityOperation_1_0_0 returns BooleanOrOperation
	 *     MultOperation returns BooleanOrOperation
	 *     MultOperation.MultOperation_1_0_0_0_0 returns BooleanOrOperation
	 *     MultOperation.DivOperation_1_0_0_1_0 returns BooleanOrOperation
	 *     AddOperation returns BooleanOrOperation
	 *     AddOperation.AddOperation_1_0_0_0_0 returns BooleanOrOperation
	 *     AddOperation.SubOperation_1_0_0_1_0 returns BooleanOrOperation
	 *     ChaindedCall returns BooleanOrOperation
	 *     ChaindedCall.ChainedCall_1_0_0_0_0 returns BooleanOrOperation
	 *     ChaindedCall.ChainedCallArrow_1_0_0_1_0 returns BooleanOrOperation
	 *     InfixOperation returns BooleanOrOperation
	 *     AtomicLiteral returns BooleanOrOperation
	 *
	 * Constraint:
	 *     (left=BooleanOperation_BooleanOrOperation_1_0_0_0_0 right=CompareOperation)
	 */
	protected void sequence_BooleanOperation(ISerializationContext context, BooleanOrOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.BOOLEAN_OR_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.BOOLEAN_OR_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.BOOLEAN_OR_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.BOOLEAN_OR_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanOperationAccess().getBooleanOrOperationLeftAction_1_0_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBooleanOperationAccess().getRightCompareOperationParserRuleCall_1_0_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns BooleanXorOperation
	 *     Expression returns BooleanXorOperation
	 *     ImpliesOperation returns BooleanXorOperation
	 *     ImpliesOperation.ImpliesOperation_1_0_0_0 returns BooleanXorOperation
	 *     BooleanOperation returns BooleanXorOperation
	 *     BooleanOperation.BooleanOrOperation_1_0_0_0_0 returns BooleanXorOperation
	 *     BooleanOperation.BooleanAndOperation_1_0_0_1_0 returns BooleanXorOperation
	 *     BooleanOperation.BooleanXorOperation_1_0_0_2_0 returns BooleanXorOperation
	 *     CompareOperation returns BooleanXorOperation
	 *     CompareOperation.CompareLEOperation_1_0_0_0_0 returns BooleanXorOperation
	 *     CompareOperation.CompareGEOperation_1_0_0_1_0 returns BooleanXorOperation
	 *     CompareOperation.CompareNEOperation_1_0_0_2_0 returns BooleanXorOperation
	 *     CompareOperation.CompareLOperation_1_0_0_3_0 returns BooleanXorOperation
	 *     CompareOperation.CompareGOperation_1_0_0_4_0 returns BooleanXorOperation
	 *     EqualityOperation returns BooleanXorOperation
	 *     EqualityOperation.EqualityOperation_1_0_0 returns BooleanXorOperation
	 *     MultOperation returns BooleanXorOperation
	 *     MultOperation.MultOperation_1_0_0_0_0 returns BooleanXorOperation
	 *     MultOperation.DivOperation_1_0_0_1_0 returns BooleanXorOperation
	 *     AddOperation returns BooleanXorOperation
	 *     AddOperation.AddOperation_1_0_0_0_0 returns BooleanXorOperation
	 *     AddOperation.SubOperation_1_0_0_1_0 returns BooleanXorOperation
	 *     ChaindedCall returns BooleanXorOperation
	 *     ChaindedCall.ChainedCall_1_0_0_0_0 returns BooleanXorOperation
	 *     ChaindedCall.ChainedCallArrow_1_0_0_1_0 returns BooleanXorOperation
	 *     InfixOperation returns BooleanXorOperation
	 *     AtomicLiteral returns BooleanXorOperation
	 *
	 * Constraint:
	 *     (left=BooleanOperation_BooleanXorOperation_1_0_0_2_0 right=CompareOperation)
	 */
	protected void sequence_BooleanOperation(ISerializationContext context, BooleanXorOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.BOOLEAN_XOR_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.BOOLEAN_XOR_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.BOOLEAN_XOR_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.BOOLEAN_XOR_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanOperationAccess().getBooleanXorOperationLeftAction_1_0_0_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBooleanOperationAccess().getRightCompareOperationParserRuleCall_1_0_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ChainedCall
	 *     Expression returns ChainedCall
	 *     ImpliesOperation returns ChainedCall
	 *     ImpliesOperation.ImpliesOperation_1_0_0_0 returns ChainedCall
	 *     BooleanOperation returns ChainedCall
	 *     BooleanOperation.BooleanOrOperation_1_0_0_0_0 returns ChainedCall
	 *     BooleanOperation.BooleanAndOperation_1_0_0_1_0 returns ChainedCall
	 *     BooleanOperation.BooleanXorOperation_1_0_0_2_0 returns ChainedCall
	 *     CompareOperation returns ChainedCall
	 *     CompareOperation.CompareLEOperation_1_0_0_0_0 returns ChainedCall
	 *     CompareOperation.CompareGEOperation_1_0_0_1_0 returns ChainedCall
	 *     CompareOperation.CompareNEOperation_1_0_0_2_0 returns ChainedCall
	 *     CompareOperation.CompareLOperation_1_0_0_3_0 returns ChainedCall
	 *     CompareOperation.CompareGOperation_1_0_0_4_0 returns ChainedCall
	 *     EqualityOperation returns ChainedCall
	 *     EqualityOperation.EqualityOperation_1_0_0 returns ChainedCall
	 *     MultOperation returns ChainedCall
	 *     MultOperation.MultOperation_1_0_0_0_0 returns ChainedCall
	 *     MultOperation.DivOperation_1_0_0_1_0 returns ChainedCall
	 *     AddOperation returns ChainedCall
	 *     AddOperation.AddOperation_1_0_0_0_0 returns ChainedCall
	 *     AddOperation.SubOperation_1_0_0_1_0 returns ChainedCall
	 *     ChaindedCall returns ChainedCall
	 *     ChaindedCall.ChainedCall_1_0_0_0_0 returns ChainedCall
	 *     ChaindedCall.ChainedCallArrow_1_0_0_1_0 returns ChainedCall
	 *     InfixOperation returns ChainedCall
	 *     AtomicLiteral returns ChainedCall
	 *
	 * Constraint:
	 *     (left=ChaindedCall_ChainedCall_1_0_0_0_0 right=InfixOperation)
	 */
	protected void sequence_ChaindedCall(ISerializationContext context, ChainedCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.CHAINED_CALL__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.CHAINED_CALL__LEFT));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.CHAINED_CALL__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.CHAINED_CALL__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getChaindedCallAccess().getChainedCallLeftAction_1_0_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getChaindedCallAccess().getRightInfixOperationParserRuleCall_1_0_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ChainedCallArrow
	 *     Expression returns ChainedCallArrow
	 *     ImpliesOperation returns ChainedCallArrow
	 *     ImpliesOperation.ImpliesOperation_1_0_0_0 returns ChainedCallArrow
	 *     BooleanOperation returns ChainedCallArrow
	 *     BooleanOperation.BooleanOrOperation_1_0_0_0_0 returns ChainedCallArrow
	 *     BooleanOperation.BooleanAndOperation_1_0_0_1_0 returns ChainedCallArrow
	 *     BooleanOperation.BooleanXorOperation_1_0_0_2_0 returns ChainedCallArrow
	 *     CompareOperation returns ChainedCallArrow
	 *     CompareOperation.CompareLEOperation_1_0_0_0_0 returns ChainedCallArrow
	 *     CompareOperation.CompareGEOperation_1_0_0_1_0 returns ChainedCallArrow
	 *     CompareOperation.CompareNEOperation_1_0_0_2_0 returns ChainedCallArrow
	 *     CompareOperation.CompareLOperation_1_0_0_3_0 returns ChainedCallArrow
	 *     CompareOperation.CompareGOperation_1_0_0_4_0 returns ChainedCallArrow
	 *     EqualityOperation returns ChainedCallArrow
	 *     EqualityOperation.EqualityOperation_1_0_0 returns ChainedCallArrow
	 *     MultOperation returns ChainedCallArrow
	 *     MultOperation.MultOperation_1_0_0_0_0 returns ChainedCallArrow
	 *     MultOperation.DivOperation_1_0_0_1_0 returns ChainedCallArrow
	 *     AddOperation returns ChainedCallArrow
	 *     AddOperation.AddOperation_1_0_0_0_0 returns ChainedCallArrow
	 *     AddOperation.SubOperation_1_0_0_1_0 returns ChainedCallArrow
	 *     ChaindedCall returns ChainedCallArrow
	 *     ChaindedCall.ChainedCall_1_0_0_0_0 returns ChainedCallArrow
	 *     ChaindedCall.ChainedCallArrow_1_0_0_1_0 returns ChainedCallArrow
	 *     InfixOperation returns ChainedCallArrow
	 *     AtomicLiteral returns ChainedCallArrow
	 *
	 * Constraint:
	 *     (left=ChaindedCall_ChainedCallArrow_1_0_0_1_0 right=InfixOperation)
	 */
	protected void sequence_ChaindedCall(ISerializationContext context, ChainedCallArrow semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.CHAINED_CALL_ARROW__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.CHAINED_CALL_ARROW__LEFT));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.CHAINED_CALL_ARROW__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.CHAINED_CALL_ARROW__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getChaindedCallAccess().getChainedCallArrowLeftAction_1_0_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getChaindedCallAccess().getRightInfixOperationParserRuleCall_1_0_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns CompareGEOperation
	 *     Expression returns CompareGEOperation
	 *     ImpliesOperation returns CompareGEOperation
	 *     ImpliesOperation.ImpliesOperation_1_0_0_0 returns CompareGEOperation
	 *     BooleanOperation returns CompareGEOperation
	 *     BooleanOperation.BooleanOrOperation_1_0_0_0_0 returns CompareGEOperation
	 *     BooleanOperation.BooleanAndOperation_1_0_0_1_0 returns CompareGEOperation
	 *     BooleanOperation.BooleanXorOperation_1_0_0_2_0 returns CompareGEOperation
	 *     CompareOperation returns CompareGEOperation
	 *     CompareOperation.CompareLEOperation_1_0_0_0_0 returns CompareGEOperation
	 *     CompareOperation.CompareGEOperation_1_0_0_1_0 returns CompareGEOperation
	 *     CompareOperation.CompareNEOperation_1_0_0_2_0 returns CompareGEOperation
	 *     CompareOperation.CompareLOperation_1_0_0_3_0 returns CompareGEOperation
	 *     CompareOperation.CompareGOperation_1_0_0_4_0 returns CompareGEOperation
	 *     EqualityOperation returns CompareGEOperation
	 *     EqualityOperation.EqualityOperation_1_0_0 returns CompareGEOperation
	 *     MultOperation returns CompareGEOperation
	 *     MultOperation.MultOperation_1_0_0_0_0 returns CompareGEOperation
	 *     MultOperation.DivOperation_1_0_0_1_0 returns CompareGEOperation
	 *     AddOperation returns CompareGEOperation
	 *     AddOperation.AddOperation_1_0_0_0_0 returns CompareGEOperation
	 *     AddOperation.SubOperation_1_0_0_1_0 returns CompareGEOperation
	 *     ChaindedCall returns CompareGEOperation
	 *     ChaindedCall.ChainedCall_1_0_0_0_0 returns CompareGEOperation
	 *     ChaindedCall.ChainedCallArrow_1_0_0_1_0 returns CompareGEOperation
	 *     InfixOperation returns CompareGEOperation
	 *     AtomicLiteral returns CompareGEOperation
	 *
	 * Constraint:
	 *     (left=CompareOperation_CompareGEOperation_1_0_0_1_0 right=EqualityOperation)
	 */
	protected void sequence_CompareOperation(ISerializationContext context, CompareGEOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.COMPARE_GE_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.COMPARE_GE_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.COMPARE_GE_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.COMPARE_GE_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompareOperationAccess().getCompareGEOperationLeftAction_1_0_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCompareOperationAccess().getRightEqualityOperationParserRuleCall_1_0_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns CompareGOperation
	 *     Expression returns CompareGOperation
	 *     ImpliesOperation returns CompareGOperation
	 *     ImpliesOperation.ImpliesOperation_1_0_0_0 returns CompareGOperation
	 *     BooleanOperation returns CompareGOperation
	 *     BooleanOperation.BooleanOrOperation_1_0_0_0_0 returns CompareGOperation
	 *     BooleanOperation.BooleanAndOperation_1_0_0_1_0 returns CompareGOperation
	 *     BooleanOperation.BooleanXorOperation_1_0_0_2_0 returns CompareGOperation
	 *     CompareOperation returns CompareGOperation
	 *     CompareOperation.CompareLEOperation_1_0_0_0_0 returns CompareGOperation
	 *     CompareOperation.CompareGEOperation_1_0_0_1_0 returns CompareGOperation
	 *     CompareOperation.CompareNEOperation_1_0_0_2_0 returns CompareGOperation
	 *     CompareOperation.CompareLOperation_1_0_0_3_0 returns CompareGOperation
	 *     CompareOperation.CompareGOperation_1_0_0_4_0 returns CompareGOperation
	 *     EqualityOperation returns CompareGOperation
	 *     EqualityOperation.EqualityOperation_1_0_0 returns CompareGOperation
	 *     MultOperation returns CompareGOperation
	 *     MultOperation.MultOperation_1_0_0_0_0 returns CompareGOperation
	 *     MultOperation.DivOperation_1_0_0_1_0 returns CompareGOperation
	 *     AddOperation returns CompareGOperation
	 *     AddOperation.AddOperation_1_0_0_0_0 returns CompareGOperation
	 *     AddOperation.SubOperation_1_0_0_1_0 returns CompareGOperation
	 *     ChaindedCall returns CompareGOperation
	 *     ChaindedCall.ChainedCall_1_0_0_0_0 returns CompareGOperation
	 *     ChaindedCall.ChainedCallArrow_1_0_0_1_0 returns CompareGOperation
	 *     InfixOperation returns CompareGOperation
	 *     AtomicLiteral returns CompareGOperation
	 *
	 * Constraint:
	 *     (left=CompareOperation_CompareGOperation_1_0_0_4_0 right=EqualityOperation)
	 */
	protected void sequence_CompareOperation(ISerializationContext context, CompareGOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.COMPARE_GOPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.COMPARE_GOPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.COMPARE_GOPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.COMPARE_GOPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompareOperationAccess().getCompareGOperationLeftAction_1_0_0_4_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCompareOperationAccess().getRightEqualityOperationParserRuleCall_1_0_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns CompareLEOperation
	 *     Expression returns CompareLEOperation
	 *     ImpliesOperation returns CompareLEOperation
	 *     ImpliesOperation.ImpliesOperation_1_0_0_0 returns CompareLEOperation
	 *     BooleanOperation returns CompareLEOperation
	 *     BooleanOperation.BooleanOrOperation_1_0_0_0_0 returns CompareLEOperation
	 *     BooleanOperation.BooleanAndOperation_1_0_0_1_0 returns CompareLEOperation
	 *     BooleanOperation.BooleanXorOperation_1_0_0_2_0 returns CompareLEOperation
	 *     CompareOperation returns CompareLEOperation
	 *     CompareOperation.CompareLEOperation_1_0_0_0_0 returns CompareLEOperation
	 *     CompareOperation.CompareGEOperation_1_0_0_1_0 returns CompareLEOperation
	 *     CompareOperation.CompareNEOperation_1_0_0_2_0 returns CompareLEOperation
	 *     CompareOperation.CompareLOperation_1_0_0_3_0 returns CompareLEOperation
	 *     CompareOperation.CompareGOperation_1_0_0_4_0 returns CompareLEOperation
	 *     EqualityOperation returns CompareLEOperation
	 *     EqualityOperation.EqualityOperation_1_0_0 returns CompareLEOperation
	 *     MultOperation returns CompareLEOperation
	 *     MultOperation.MultOperation_1_0_0_0_0 returns CompareLEOperation
	 *     MultOperation.DivOperation_1_0_0_1_0 returns CompareLEOperation
	 *     AddOperation returns CompareLEOperation
	 *     AddOperation.AddOperation_1_0_0_0_0 returns CompareLEOperation
	 *     AddOperation.SubOperation_1_0_0_1_0 returns CompareLEOperation
	 *     ChaindedCall returns CompareLEOperation
	 *     ChaindedCall.ChainedCall_1_0_0_0_0 returns CompareLEOperation
	 *     ChaindedCall.ChainedCallArrow_1_0_0_1_0 returns CompareLEOperation
	 *     InfixOperation returns CompareLEOperation
	 *     AtomicLiteral returns CompareLEOperation
	 *
	 * Constraint:
	 *     (left=CompareOperation_CompareLEOperation_1_0_0_0_0 right=EqualityOperation)
	 */
	protected void sequence_CompareOperation(ISerializationContext context, CompareLEOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.COMPARE_LE_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.COMPARE_LE_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.COMPARE_LE_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.COMPARE_LE_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompareOperationAccess().getCompareLEOperationLeftAction_1_0_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCompareOperationAccess().getRightEqualityOperationParserRuleCall_1_0_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns CompareLOperation
	 *     Expression returns CompareLOperation
	 *     ImpliesOperation returns CompareLOperation
	 *     ImpliesOperation.ImpliesOperation_1_0_0_0 returns CompareLOperation
	 *     BooleanOperation returns CompareLOperation
	 *     BooleanOperation.BooleanOrOperation_1_0_0_0_0 returns CompareLOperation
	 *     BooleanOperation.BooleanAndOperation_1_0_0_1_0 returns CompareLOperation
	 *     BooleanOperation.BooleanXorOperation_1_0_0_2_0 returns CompareLOperation
	 *     CompareOperation returns CompareLOperation
	 *     CompareOperation.CompareLEOperation_1_0_0_0_0 returns CompareLOperation
	 *     CompareOperation.CompareGEOperation_1_0_0_1_0 returns CompareLOperation
	 *     CompareOperation.CompareNEOperation_1_0_0_2_0 returns CompareLOperation
	 *     CompareOperation.CompareLOperation_1_0_0_3_0 returns CompareLOperation
	 *     CompareOperation.CompareGOperation_1_0_0_4_0 returns CompareLOperation
	 *     EqualityOperation returns CompareLOperation
	 *     EqualityOperation.EqualityOperation_1_0_0 returns CompareLOperation
	 *     MultOperation returns CompareLOperation
	 *     MultOperation.MultOperation_1_0_0_0_0 returns CompareLOperation
	 *     MultOperation.DivOperation_1_0_0_1_0 returns CompareLOperation
	 *     AddOperation returns CompareLOperation
	 *     AddOperation.AddOperation_1_0_0_0_0 returns CompareLOperation
	 *     AddOperation.SubOperation_1_0_0_1_0 returns CompareLOperation
	 *     ChaindedCall returns CompareLOperation
	 *     ChaindedCall.ChainedCall_1_0_0_0_0 returns CompareLOperation
	 *     ChaindedCall.ChainedCallArrow_1_0_0_1_0 returns CompareLOperation
	 *     InfixOperation returns CompareLOperation
	 *     AtomicLiteral returns CompareLOperation
	 *
	 * Constraint:
	 *     (left=CompareOperation_CompareLOperation_1_0_0_3_0 right=EqualityOperation)
	 */
	protected void sequence_CompareOperation(ISerializationContext context, CompareLOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.COMPARE_LOPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.COMPARE_LOPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.COMPARE_LOPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.COMPARE_LOPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompareOperationAccess().getCompareLOperationLeftAction_1_0_0_3_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCompareOperationAccess().getRightEqualityOperationParserRuleCall_1_0_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns CompareNEOperation
	 *     Expression returns CompareNEOperation
	 *     ImpliesOperation returns CompareNEOperation
	 *     ImpliesOperation.ImpliesOperation_1_0_0_0 returns CompareNEOperation
	 *     BooleanOperation returns CompareNEOperation
	 *     BooleanOperation.BooleanOrOperation_1_0_0_0_0 returns CompareNEOperation
	 *     BooleanOperation.BooleanAndOperation_1_0_0_1_0 returns CompareNEOperation
	 *     BooleanOperation.BooleanXorOperation_1_0_0_2_0 returns CompareNEOperation
	 *     CompareOperation returns CompareNEOperation
	 *     CompareOperation.CompareLEOperation_1_0_0_0_0 returns CompareNEOperation
	 *     CompareOperation.CompareGEOperation_1_0_0_1_0 returns CompareNEOperation
	 *     CompareOperation.CompareNEOperation_1_0_0_2_0 returns CompareNEOperation
	 *     CompareOperation.CompareLOperation_1_0_0_3_0 returns CompareNEOperation
	 *     CompareOperation.CompareGOperation_1_0_0_4_0 returns CompareNEOperation
	 *     EqualityOperation returns CompareNEOperation
	 *     EqualityOperation.EqualityOperation_1_0_0 returns CompareNEOperation
	 *     MultOperation returns CompareNEOperation
	 *     MultOperation.MultOperation_1_0_0_0_0 returns CompareNEOperation
	 *     MultOperation.DivOperation_1_0_0_1_0 returns CompareNEOperation
	 *     AddOperation returns CompareNEOperation
	 *     AddOperation.AddOperation_1_0_0_0_0 returns CompareNEOperation
	 *     AddOperation.SubOperation_1_0_0_1_0 returns CompareNEOperation
	 *     ChaindedCall returns CompareNEOperation
	 *     ChaindedCall.ChainedCall_1_0_0_0_0 returns CompareNEOperation
	 *     ChaindedCall.ChainedCallArrow_1_0_0_1_0 returns CompareNEOperation
	 *     InfixOperation returns CompareNEOperation
	 *     AtomicLiteral returns CompareNEOperation
	 *
	 * Constraint:
	 *     (left=CompareOperation_CompareNEOperation_1_0_0_2_0 right=EqualityOperation)
	 */
	protected void sequence_CompareOperation(ISerializationContext context, CompareNEOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.COMPARE_NE_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.COMPARE_NE_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.COMPARE_NE_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.COMPARE_NE_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompareOperationAccess().getCompareNEOperationLeftAction_1_0_0_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCompareOperationAccess().getRightEqualityOperationParserRuleCall_1_0_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Method returns DefMethod
	 *     DefMethod returns DefMethod
	 *
	 * Constraint:
	 *     (tags+=Tag* type=Type? name=ID (params+=Param params+=Param*)? block=Block)
	 */
	protected void sequence_DefMethod(ISerializationContext context, DefMethod semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns EqualityOperation
	 *     Expression returns EqualityOperation
	 *     ImpliesOperation returns EqualityOperation
	 *     ImpliesOperation.ImpliesOperation_1_0_0_0 returns EqualityOperation
	 *     BooleanOperation returns EqualityOperation
	 *     BooleanOperation.BooleanOrOperation_1_0_0_0_0 returns EqualityOperation
	 *     BooleanOperation.BooleanAndOperation_1_0_0_1_0 returns EqualityOperation
	 *     BooleanOperation.BooleanXorOperation_1_0_0_2_0 returns EqualityOperation
	 *     CompareOperation returns EqualityOperation
	 *     CompareOperation.CompareLEOperation_1_0_0_0_0 returns EqualityOperation
	 *     CompareOperation.CompareGEOperation_1_0_0_1_0 returns EqualityOperation
	 *     CompareOperation.CompareNEOperation_1_0_0_2_0 returns EqualityOperation
	 *     CompareOperation.CompareLOperation_1_0_0_3_0 returns EqualityOperation
	 *     CompareOperation.CompareGOperation_1_0_0_4_0 returns EqualityOperation
	 *     EqualityOperation returns EqualityOperation
	 *     EqualityOperation.EqualityOperation_1_0_0 returns EqualityOperation
	 *     MultOperation returns EqualityOperation
	 *     MultOperation.MultOperation_1_0_0_0_0 returns EqualityOperation
	 *     MultOperation.DivOperation_1_0_0_1_0 returns EqualityOperation
	 *     AddOperation returns EqualityOperation
	 *     AddOperation.AddOperation_1_0_0_0_0 returns EqualityOperation
	 *     AddOperation.SubOperation_1_0_0_1_0 returns EqualityOperation
	 *     ChaindedCall returns EqualityOperation
	 *     ChaindedCall.ChainedCall_1_0_0_0_0 returns EqualityOperation
	 *     ChaindedCall.ChainedCallArrow_1_0_0_1_0 returns EqualityOperation
	 *     InfixOperation returns EqualityOperation
	 *     AtomicLiteral returns EqualityOperation
	 *
	 * Constraint:
	 *     (left=EqualityOperation_EqualityOperation_1_0_0 op='==' right=MultOperation)
	 */
	protected void sequence_EqualityOperation(ISerializationContext context, EqualityOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.EQUALITY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.EQUALITY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.EQUALITY_OPERATION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.EQUALITY_OPERATION__OP));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.EQUALITY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.EQUALITY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualityOperationAccess().getEqualityOperationLeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEqualityOperationAccess().getOpEqualsSignEqualsSignKeyword_1_0_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getEqualityOperationAccess().getRightMultOperationParserRuleCall_1_0_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Field returns Field
	 *     Symbol returns Field
	 *
	 * Constraint:
	 *     (type=Type name=ID)
	 */
	protected void sequence_Field(ISerializationContext context, Field semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.FIELD__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.FIELD__TYPE));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.FIELD__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.FIELD__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFieldAccess().getTypeTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getFieldAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ForLoop
	 *     ForLoop returns ForLoop
	 *
	 * Constraint:
	 *     (type=Type name=ID collection=Expression block=Block)
	 */
	protected void sequence_ForLoop(ISerializationContext context, ForLoop semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.FOR_LOOP__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.FOR_LOOP__TYPE));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.FOR_LOOP__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.FOR_LOOP__NAME));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.FOR_LOOP__COLLECTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.FOR_LOOP__COLLECTION));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.FOR_LOOP__BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.FOR_LOOP__BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForLoopAccess().getTypeTypeParserRuleCall_3_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getForLoopAccess().getNameIDTerminalRuleCall_4_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getForLoopAccess().getCollectionExpressionParserRuleCall_6_0(), semanticObject.getCollection());
		feeder.accept(grammarAccess.getForLoopAccess().getBlockBlockParserRuleCall_8_0(), semanticObject.getBlock());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IfStatement
	 *     IfStatement returns IfStatement
	 *
	 * Constraint:
	 *     (condition=Expression thenBranch=Block elseBranch=Block?)
	 */
	protected void sequence_IfStatement(ISerializationContext context, IfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ImpliesOperation
	 *     Expression returns ImpliesOperation
	 *     ImpliesOperation returns ImpliesOperation
	 *     ImpliesOperation.ImpliesOperation_1_0_0_0 returns ImpliesOperation
	 *     BooleanOperation returns ImpliesOperation
	 *     BooleanOperation.BooleanOrOperation_1_0_0_0_0 returns ImpliesOperation
	 *     BooleanOperation.BooleanAndOperation_1_0_0_1_0 returns ImpliesOperation
	 *     BooleanOperation.BooleanXorOperation_1_0_0_2_0 returns ImpliesOperation
	 *     CompareOperation returns ImpliesOperation
	 *     CompareOperation.CompareLEOperation_1_0_0_0_0 returns ImpliesOperation
	 *     CompareOperation.CompareGEOperation_1_0_0_1_0 returns ImpliesOperation
	 *     CompareOperation.CompareNEOperation_1_0_0_2_0 returns ImpliesOperation
	 *     CompareOperation.CompareLOperation_1_0_0_3_0 returns ImpliesOperation
	 *     CompareOperation.CompareGOperation_1_0_0_4_0 returns ImpliesOperation
	 *     EqualityOperation returns ImpliesOperation
	 *     EqualityOperation.EqualityOperation_1_0_0 returns ImpliesOperation
	 *     MultOperation returns ImpliesOperation
	 *     MultOperation.MultOperation_1_0_0_0_0 returns ImpliesOperation
	 *     MultOperation.DivOperation_1_0_0_1_0 returns ImpliesOperation
	 *     AddOperation returns ImpliesOperation
	 *     AddOperation.AddOperation_1_0_0_0_0 returns ImpliesOperation
	 *     AddOperation.SubOperation_1_0_0_1_0 returns ImpliesOperation
	 *     ChaindedCall returns ImpliesOperation
	 *     ChaindedCall.ChainedCall_1_0_0_0_0 returns ImpliesOperation
	 *     ChaindedCall.ChainedCallArrow_1_0_0_1_0 returns ImpliesOperation
	 *     InfixOperation returns ImpliesOperation
	 *     AtomicLiteral returns ImpliesOperation
	 *
	 * Constraint:
	 *     (left=ImpliesOperation_ImpliesOperation_1_0_0_0 right=BooleanOperation)
	 */
	protected void sequence_ImpliesOperation(ISerializationContext context, ImpliesOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.IMPLIES_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.IMPLIES_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.IMPLIES_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.IMPLIES_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImpliesOperationAccess().getImpliesOperationLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getImpliesOperationAccess().getRightBooleanOperationParserRuleCall_1_0_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     (ref=[Root|ID] name=ID)
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.IMPORT__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.IMPORT__REF));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.IMPORT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.IMPORT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getRefRootIDTerminalRuleCall_1_0_1(), semanticObject.getRef());
		feeder.accept(grammarAccess.getImportAccess().getNameIDTerminalRuleCall_3_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ConstructorOperation
	 *     Expression returns ConstructorOperation
	 *     ImpliesOperation returns ConstructorOperation
	 *     ImpliesOperation.ImpliesOperation_1_0_0_0 returns ConstructorOperation
	 *     BooleanOperation returns ConstructorOperation
	 *     BooleanOperation.BooleanOrOperation_1_0_0_0_0 returns ConstructorOperation
	 *     BooleanOperation.BooleanAndOperation_1_0_0_1_0 returns ConstructorOperation
	 *     BooleanOperation.BooleanXorOperation_1_0_0_2_0 returns ConstructorOperation
	 *     CompareOperation returns ConstructorOperation
	 *     CompareOperation.CompareLEOperation_1_0_0_0_0 returns ConstructorOperation
	 *     CompareOperation.CompareGEOperation_1_0_0_1_0 returns ConstructorOperation
	 *     CompareOperation.CompareNEOperation_1_0_0_2_0 returns ConstructorOperation
	 *     CompareOperation.CompareLOperation_1_0_0_3_0 returns ConstructorOperation
	 *     CompareOperation.CompareGOperation_1_0_0_4_0 returns ConstructorOperation
	 *     EqualityOperation returns ConstructorOperation
	 *     EqualityOperation.EqualityOperation_1_0_0 returns ConstructorOperation
	 *     MultOperation returns ConstructorOperation
	 *     MultOperation.MultOperation_1_0_0_0_0 returns ConstructorOperation
	 *     MultOperation.DivOperation_1_0_0_1_0 returns ConstructorOperation
	 *     AddOperation returns ConstructorOperation
	 *     AddOperation.AddOperation_1_0_0_0_0 returns ConstructorOperation
	 *     AddOperation.SubOperation_1_0_0_1_0 returns ConstructorOperation
	 *     ChaindedCall returns ConstructorOperation
	 *     ChaindedCall.ChainedCall_1_0_0_0_0 returns ConstructorOperation
	 *     ChaindedCall.ChainedCallArrow_1_0_0_1_0 returns ConstructorOperation
	 *     InfixOperation returns ConstructorOperation
	 *     AtomicLiteral returns ConstructorOperation
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_InfixOperation(ISerializationContext context, ConstructorOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.CONSTRUCTOR_OPERATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.CONSTRUCTOR_OPERATION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInfixOperationAccess().getNameIDTerminalRuleCall_2_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns NegInfixOperation
	 *     Expression returns NegInfixOperation
	 *     ImpliesOperation returns NegInfixOperation
	 *     ImpliesOperation.ImpliesOperation_1_0_0_0 returns NegInfixOperation
	 *     BooleanOperation returns NegInfixOperation
	 *     BooleanOperation.BooleanOrOperation_1_0_0_0_0 returns NegInfixOperation
	 *     BooleanOperation.BooleanAndOperation_1_0_0_1_0 returns NegInfixOperation
	 *     BooleanOperation.BooleanXorOperation_1_0_0_2_0 returns NegInfixOperation
	 *     CompareOperation returns NegInfixOperation
	 *     CompareOperation.CompareLEOperation_1_0_0_0_0 returns NegInfixOperation
	 *     CompareOperation.CompareGEOperation_1_0_0_1_0 returns NegInfixOperation
	 *     CompareOperation.CompareNEOperation_1_0_0_2_0 returns NegInfixOperation
	 *     CompareOperation.CompareLOperation_1_0_0_3_0 returns NegInfixOperation
	 *     CompareOperation.CompareGOperation_1_0_0_4_0 returns NegInfixOperation
	 *     EqualityOperation returns NegInfixOperation
	 *     EqualityOperation.EqualityOperation_1_0_0 returns NegInfixOperation
	 *     MultOperation returns NegInfixOperation
	 *     MultOperation.MultOperation_1_0_0_0_0 returns NegInfixOperation
	 *     MultOperation.DivOperation_1_0_0_1_0 returns NegInfixOperation
	 *     AddOperation returns NegInfixOperation
	 *     AddOperation.AddOperation_1_0_0_0_0 returns NegInfixOperation
	 *     AddOperation.SubOperation_1_0_0_1_0 returns NegInfixOperation
	 *     ChaindedCall returns NegInfixOperation
	 *     ChaindedCall.ChainedCall_1_0_0_0_0 returns NegInfixOperation
	 *     ChaindedCall.ChainedCallArrow_1_0_0_1_0 returns NegInfixOperation
	 *     InfixOperation returns NegInfixOperation
	 *     AtomicLiteral returns NegInfixOperation
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_InfixOperation(ISerializationContext context, NegInfixOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.NEG_INFIX_OPERATION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.NEG_INFIX_OPERATION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInfixOperationAccess().getExpressionExpressionParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns NotInfixOperation
	 *     Expression returns NotInfixOperation
	 *     ImpliesOperation returns NotInfixOperation
	 *     ImpliesOperation.ImpliesOperation_1_0_0_0 returns NotInfixOperation
	 *     BooleanOperation returns NotInfixOperation
	 *     BooleanOperation.BooleanOrOperation_1_0_0_0_0 returns NotInfixOperation
	 *     BooleanOperation.BooleanAndOperation_1_0_0_1_0 returns NotInfixOperation
	 *     BooleanOperation.BooleanXorOperation_1_0_0_2_0 returns NotInfixOperation
	 *     CompareOperation returns NotInfixOperation
	 *     CompareOperation.CompareLEOperation_1_0_0_0_0 returns NotInfixOperation
	 *     CompareOperation.CompareGEOperation_1_0_0_1_0 returns NotInfixOperation
	 *     CompareOperation.CompareNEOperation_1_0_0_2_0 returns NotInfixOperation
	 *     CompareOperation.CompareLOperation_1_0_0_3_0 returns NotInfixOperation
	 *     CompareOperation.CompareGOperation_1_0_0_4_0 returns NotInfixOperation
	 *     EqualityOperation returns NotInfixOperation
	 *     EqualityOperation.EqualityOperation_1_0_0 returns NotInfixOperation
	 *     MultOperation returns NotInfixOperation
	 *     MultOperation.MultOperation_1_0_0_0_0 returns NotInfixOperation
	 *     MultOperation.DivOperation_1_0_0_1_0 returns NotInfixOperation
	 *     AddOperation returns NotInfixOperation
	 *     AddOperation.AddOperation_1_0_0_0_0 returns NotInfixOperation
	 *     AddOperation.SubOperation_1_0_0_1_0 returns NotInfixOperation
	 *     ChaindedCall returns NotInfixOperation
	 *     ChaindedCall.ChainedCall_1_0_0_0_0 returns NotInfixOperation
	 *     ChaindedCall.ChainedCallArrow_1_0_0_1_0 returns NotInfixOperation
	 *     InfixOperation returns NotInfixOperation
	 *     AtomicLiteral returns NotInfixOperation
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_InfixOperation(ISerializationContext context, NotInfixOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.NOT_INFIX_OPERATION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.NOT_INFIX_OPERATION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInfixOperationAccess().getExpressionExpressionParserRuleCall_0_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns OperationCallOperation
	 *     Expression returns OperationCallOperation
	 *     ImpliesOperation returns OperationCallOperation
	 *     ImpliesOperation.ImpliesOperation_1_0_0_0 returns OperationCallOperation
	 *     BooleanOperation returns OperationCallOperation
	 *     BooleanOperation.BooleanOrOperation_1_0_0_0_0 returns OperationCallOperation
	 *     BooleanOperation.BooleanAndOperation_1_0_0_1_0 returns OperationCallOperation
	 *     BooleanOperation.BooleanXorOperation_1_0_0_2_0 returns OperationCallOperation
	 *     CompareOperation returns OperationCallOperation
	 *     CompareOperation.CompareLEOperation_1_0_0_0_0 returns OperationCallOperation
	 *     CompareOperation.CompareGEOperation_1_0_0_1_0 returns OperationCallOperation
	 *     CompareOperation.CompareNEOperation_1_0_0_2_0 returns OperationCallOperation
	 *     CompareOperation.CompareLOperation_1_0_0_3_0 returns OperationCallOperation
	 *     CompareOperation.CompareGOperation_1_0_0_4_0 returns OperationCallOperation
	 *     EqualityOperation returns OperationCallOperation
	 *     EqualityOperation.EqualityOperation_1_0_0 returns OperationCallOperation
	 *     MultOperation returns OperationCallOperation
	 *     MultOperation.MultOperation_1_0_0_0_0 returns OperationCallOperation
	 *     MultOperation.DivOperation_1_0_0_1_0 returns OperationCallOperation
	 *     AddOperation returns OperationCallOperation
	 *     AddOperation.AddOperation_1_0_0_0_0 returns OperationCallOperation
	 *     AddOperation.SubOperation_1_0_0_1_0 returns OperationCallOperation
	 *     ChaindedCall returns OperationCallOperation
	 *     ChaindedCall.ChainedCall_1_0_0_0_0 returns OperationCallOperation
	 *     ChaindedCall.ChainedCallArrow_1_0_0_1_0 returns OperationCallOperation
	 *     InfixOperation returns OperationCallOperation
	 *     AtomicLiteral returns OperationCallOperation
	 *
	 * Constraint:
	 *     (name=ID (parameters+=ParamCall parameters+=ParamCall*)?)
	 */
	protected void sequence_InfixOperation(ISerializationContext context, OperationCallOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns LetStatement
	 *     LetStatement returns LetStatement
	 *
	 * Constraint:
	 *     (bindings+=VarAssign bindings+=VarAssign* (block=Expression | block=LetStatement))
	 */
	protected void sequence_LetStatement(ISerializationContext context, LetStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns LiteralType
	 *     LiteralType returns LiteralType
	 *
	 * Constraint:
	 *     (lit='Boolean' | lit='Real' | lit='Int' | lit='String')
	 */
	protected void sequence_LiteralType(ISerializationContext context, LiteralType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DivOperation
	 *     Expression returns DivOperation
	 *     ImpliesOperation returns DivOperation
	 *     ImpliesOperation.ImpliesOperation_1_0_0_0 returns DivOperation
	 *     BooleanOperation returns DivOperation
	 *     BooleanOperation.BooleanOrOperation_1_0_0_0_0 returns DivOperation
	 *     BooleanOperation.BooleanAndOperation_1_0_0_1_0 returns DivOperation
	 *     BooleanOperation.BooleanXorOperation_1_0_0_2_0 returns DivOperation
	 *     CompareOperation returns DivOperation
	 *     CompareOperation.CompareLEOperation_1_0_0_0_0 returns DivOperation
	 *     CompareOperation.CompareGEOperation_1_0_0_1_0 returns DivOperation
	 *     CompareOperation.CompareNEOperation_1_0_0_2_0 returns DivOperation
	 *     CompareOperation.CompareLOperation_1_0_0_3_0 returns DivOperation
	 *     CompareOperation.CompareGOperation_1_0_0_4_0 returns DivOperation
	 *     EqualityOperation returns DivOperation
	 *     EqualityOperation.EqualityOperation_1_0_0 returns DivOperation
	 *     MultOperation returns DivOperation
	 *     MultOperation.MultOperation_1_0_0_0_0 returns DivOperation
	 *     MultOperation.DivOperation_1_0_0_1_0 returns DivOperation
	 *     AddOperation returns DivOperation
	 *     AddOperation.AddOperation_1_0_0_0_0 returns DivOperation
	 *     AddOperation.SubOperation_1_0_0_1_0 returns DivOperation
	 *     ChaindedCall returns DivOperation
	 *     ChaindedCall.ChainedCall_1_0_0_0_0 returns DivOperation
	 *     ChaindedCall.ChainedCallArrow_1_0_0_1_0 returns DivOperation
	 *     InfixOperation returns DivOperation
	 *     AtomicLiteral returns DivOperation
	 *
	 * Constraint:
	 *     (left=MultOperation_DivOperation_1_0_0_1_0 right=AddOperation)
	 */
	protected void sequence_MultOperation(ISerializationContext context, DivOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.DIV_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.DIV_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.DIV_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.DIV_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultOperationAccess().getDivOperationLeftAction_1_0_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultOperationAccess().getRightAddOperationParserRuleCall_1_0_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns MultOperation
	 *     Expression returns MultOperation
	 *     ImpliesOperation returns MultOperation
	 *     ImpliesOperation.ImpliesOperation_1_0_0_0 returns MultOperation
	 *     BooleanOperation returns MultOperation
	 *     BooleanOperation.BooleanOrOperation_1_0_0_0_0 returns MultOperation
	 *     BooleanOperation.BooleanAndOperation_1_0_0_1_0 returns MultOperation
	 *     BooleanOperation.BooleanXorOperation_1_0_0_2_0 returns MultOperation
	 *     CompareOperation returns MultOperation
	 *     CompareOperation.CompareLEOperation_1_0_0_0_0 returns MultOperation
	 *     CompareOperation.CompareGEOperation_1_0_0_1_0 returns MultOperation
	 *     CompareOperation.CompareNEOperation_1_0_0_2_0 returns MultOperation
	 *     CompareOperation.CompareLOperation_1_0_0_3_0 returns MultOperation
	 *     CompareOperation.CompareGOperation_1_0_0_4_0 returns MultOperation
	 *     EqualityOperation returns MultOperation
	 *     EqualityOperation.EqualityOperation_1_0_0 returns MultOperation
	 *     MultOperation returns MultOperation
	 *     MultOperation.MultOperation_1_0_0_0_0 returns MultOperation
	 *     MultOperation.DivOperation_1_0_0_1_0 returns MultOperation
	 *     AddOperation returns MultOperation
	 *     AddOperation.AddOperation_1_0_0_0_0 returns MultOperation
	 *     AddOperation.SubOperation_1_0_0_1_0 returns MultOperation
	 *     ChaindedCall returns MultOperation
	 *     ChaindedCall.ChainedCall_1_0_0_0_0 returns MultOperation
	 *     ChaindedCall.ChainedCallArrow_1_0_0_1_0 returns MultOperation
	 *     InfixOperation returns MultOperation
	 *     AtomicLiteral returns MultOperation
	 *
	 * Constraint:
	 *     (left=MultOperation_MultOperation_1_0_0_0_0 right=AddOperation)
	 */
	protected void sequence_MultOperation(ISerializationContext context, MultOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.MULT_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.MULT_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.MULT_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.MULT_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultOperationAccess().getMultOperationLeftAction_1_0_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultOperationAccess().getRightAddOperationParserRuleCall_1_0_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AleClass returns NewClass
	 *     NewClass returns NewClass
	 *
	 * Constraint:
	 *     (name=ID (superClass+=[AleClass|Qualified] superClass+=[AleClass|Qualified]*)? fields+=Field* methods+=Method*)
	 */
	protected void sequence_NewClass(ISerializationContext context, NewClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AleClass returns OpenClass
	 *     OpenClass returns OpenClass
	 *
	 * Constraint:
	 *     (name=ID (superClass+=[AleClass|Qualified] superClass+=[AleClass|Qualified]*)? fields+=Field* methods+=Method*)
	 */
	protected void sequence_OpenClass(ISerializationContext context, OpenClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Method returns OverrideMethod
	 *     OverrideMethod returns OverrideMethod
	 *
	 * Constraint:
	 *     (tags+=Tag* type=Type name=ID (params+=Param params+=Param*)? block=Block)
	 */
	protected void sequence_OverrideMethod(ISerializationContext context, OverrideMethod semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParamCall returns ParamCall
	 *
	 * Constraint:
	 *     (lambda=ID? expression=Expression)
	 */
	protected void sequence_ParamCall(ISerializationContext context, ParamCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Symbol returns Param
	 *     Param returns Param
	 *
	 * Constraint:
	 *     (type=Type name=ID)
	 */
	protected void sequence_Param(ISerializationContext context, Param semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.PARAM__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.PARAM__TYPE));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.PARAM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.PARAM__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParamAccess().getTypeTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getParamAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ReturnStatement
	 *     ReturnStatement returns ReturnStatement
	 *
	 * Constraint:
	 *     returned=Expression
	 */
	protected void sequence_ReturnStatement(ISerializationContext context, ReturnStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.RETURN_STATEMENT__RETURNED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.RETURN_STATEMENT__RETURNED));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReturnStatementAccess().getReturnedExpressionParserRuleCall_2_0(), semanticObject.getReturned());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Root returns Root
	 *
	 * Constraint:
	 *     (name=Qualified imports+=Import* classes+=AleClass*)
	 */
	protected void sequence_Root(ISerializationContext context, Root semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeSystem returns BooleanTypeT
	 *
	 * Constraint:
	 *     {BooleanTypeT}
	 */
	protected void sequence_TypeSystem(ISerializationContext context, BooleanTypeT semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeSystem returns ClassTypeT
	 *
	 * Constraint:
	 *     clazz=[AleClass|ID]
	 */
	protected void sequence_TypeSystem(ISerializationContext context, ClassTypeT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.CLASS_TYPE_T__CLAZZ) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.CLASS_TYPE_T__CLAZZ));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeSystemAccess().getClazzAleClassIDTerminalRuleCall_6_2_0_1(), semanticObject.getClazz());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypeSystem returns IntTypeT
	 *
	 * Constraint:
	 *     {IntTypeT}
	 */
	protected void sequence_TypeSystem(ISerializationContext context, IntTypeT semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeSystem returns NullTypeT
	 *
	 * Constraint:
	 *     {NullTypeT}
	 */
	protected void sequence_TypeSystem(ISerializationContext context, NullTypeT semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeSystem returns RealTypeT
	 *
	 * Constraint:
	 *     {RealTypeT}
	 */
	protected void sequence_TypeSystem(ISerializationContext context, RealTypeT semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeSystem returns SequenceTypeT
	 *
	 * Constraint:
	 *     subType=TypeSystem
	 */
	protected void sequence_TypeSystem(ISerializationContext context, SequenceTypeT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.SEQUENCE_TYPE_T__SUB_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.SEQUENCE_TYPE_T__SUB_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeSystemAccess().getSubTypeTypeSystemParserRuleCall_5_2_0(), semanticObject.getSubType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypeSystem returns StringTypeT
	 *
	 * Constraint:
	 *     {StringTypeT}
	 */
	protected void sequence_TypeSystem(ISerializationContext context, StringTypeT semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns OrderedSetType
	 *
	 * Constraint:
	 *     subType=Type
	 */
	protected void sequence_Type(ISerializationContext context, OrderedSetType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.ORDERED_SET_TYPE__SUB_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.ORDERED_SET_TYPE__SUB_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeAccess().getSubTypeTypeParserRuleCall_3_3_0(), semanticObject.getSubType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns OutOfScopeType
	 *
	 * Constraint:
	 *     externalClass=ID
	 */
	protected void sequence_Type(ISerializationContext context, OutOfScopeType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.OUT_OF_SCOPE_TYPE__EXTERNAL_CLASS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.OUT_OF_SCOPE_TYPE__EXTERNAL_CLASS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeAccess().getExternalClassIDTerminalRuleCall_1_1_0(), semanticObject.getExternalClass());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns SequenceType
	 *
	 * Constraint:
	 *     subType=Type
	 */
	protected void sequence_Type(ISerializationContext context, SequenceType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.SEQUENCE_TYPE__SUB_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.SEQUENCE_TYPE__SUB_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeAccess().getSubTypeTypeParserRuleCall_2_3_0(), semanticObject.getSubType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns VarAssign
	 *     VarAssign returns VarAssign
	 *     Symbol returns VarAssign
	 *
	 * Constraint:
	 *     (type=Type name=ID value=Expression)
	 */
	protected void sequence_VarAssign(ISerializationContext context, VarAssign semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.VAR_ASSIGN__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.VAR_ASSIGN__TYPE));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.VAR_ASSIGN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.VAR_ASSIGN__NAME));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.VAR_ASSIGN__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.VAR_ASSIGN__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarAssignAccess().getTypeTypeParserRuleCall_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getVarAssignAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVarAssignAccess().getValueExpressionParserRuleCall_4_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns WhileStatement
	 *     WhileStatement returns WhileStatement
	 *
	 * Constraint:
	 *     (condition=Expression whileBlock=Block)
	 */
	protected void sequence_WhileStatement(ISerializationContext context, WhileStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.WHILE_STATEMENT__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.WHILE_STATEMENT__CONDITION));
			if (transientValues.isValueTransient(semanticObject, AlePackage.Literals.WHILE_STATEMENT__WHILE_BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AlePackage.Literals.WHILE_STATEMENT__WHILE_BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileStatementAccess().getConditionExpressionParserRuleCall_3_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getWhileStatementAccess().getWhileBlockBlockParserRuleCall_5_0(), semanticObject.getWhileBlock());
		feeder.finish();
	}
	
	
}
