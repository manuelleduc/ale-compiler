/*
 * generated by Xtext 2.10.0
 */
package dsl.xtext.generator

import dsl.xtext.dsl.DSL
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dsl.xtext.dsl.Behavior
import dsl.xtext.dsl.Syntax
import org.eclipse.emf.ecore.EPackage
import org.eclipse.emf.ecore.EcorePackage
import org.eclipse.emf.ecore.xmi.impl.XMIResourceFactoryImpl
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl
import java.util.List
import org.eclipse.emf.ecore.EClass
import ale.xtext.ale.Field
import java.util.Map

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class DslGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {

		val dsl = resource.allContents.filter(typeof(DSL)).head

		val models = dsl.syntaxes.map[loadModel]

		this.generateDynamicModel(dsl, models)
//		fsa.generateFile('greetings.txt', 'People to greet: ' + 
//			resource.allContents
//				.filter(typeof(Greeting))
//				.map[name]
//				.join(', '))
	}

	def getLoadModel(Syntax syntax) {
		if (!EPackage.Registry.INSTANCE.containsKey(EcorePackage.eNS_URI))
			EPackage.Registry.INSTANCE.put(EcorePackage.eNS_URI, EcorePackage.eINSTANCE)

		Resource.Factory.Registry.INSTANCE.extensionToFactoryMap.put("ecore", new XMIResourceFactoryImpl)

		val rs = new ResourceSetImpl

		rs.packageRegistry.getEPackage(syntax.value)
	}

	def void generateDynamicModel(DSL dsl, List<EPackage> models) {
		dsl.behaviours.forEach[generateDynamicModel(it, models)]
	}

	def void generateDynamicModel(Behavior behavior, List<EPackage> models) {
		val root = behavior.value
		val behaviorName = root.name

		val Map<EClass, List<Field>> clazzList = newHashMap()

		root.classes.forEach [ extendedClass |
			if (!extendedClass.fields.empty) {
				val fields = extendedClass.fields
				val baseClass = models.map [ m |
					m.eAllContents.filter(typeof(EClass)).filter[c|c.name == extendedClass.name]
				].head.head
				clazzList.put(baseClass, fields)
			}
		]
	}

}
