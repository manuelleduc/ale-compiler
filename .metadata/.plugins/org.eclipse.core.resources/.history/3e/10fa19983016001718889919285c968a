package ale.xtext;

import ale.xtext.ale.AlePackage;
import ale.xtext.ale.Field;
import ale.xtext.ale.NewClass;
import ale.xtext.ale.OpenClass;
import ale.xtext.ale.Root;
import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.google.inject.Provider;
import it.xsemantics.runtime.ErrorInformation;
import it.xsemantics.runtime.Result;
import it.xsemantics.runtime.RuleApplicationTrace;
import it.xsemantics.runtime.RuleFailedException;
import it.xsemantics.runtime.XsemanticsRuntimeSystem;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.xtext.util.PolymorphicDispatcher;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.Functions.Function2;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.MapExtensions;

@SuppressWarnings("all")
public class AleType extends XsemanticsRuntimeSystem {
  public final static String SUPEROPENCLASSES = "ale.xtext.SuperOpenClasses";
  
  public final static String SUPERNEWCLASSES = "ale.xtext.SuperNewClasses";
  
  private PolymorphicDispatcher<Boolean> superOpenClassesDispatcher;
  
  private PolymorphicDispatcher<Boolean> superNewClassesDispatcher;
  
  public AleType() {
    init();
  }
  
  public void init() {
    superOpenClassesDispatcher = buildPolymorphicDispatcher(
    	"superOpenClassesImpl", 3);
    superNewClassesDispatcher = buildPolymorphicDispatcher(
    	"superNewClassesImpl", 3);
  }
  
  public Boolean superOpenClasses(final OpenClass openClass, final List<OpenClass> existing) throws RuleFailedException {
    return superOpenClasses(null, openClass, existing);
  }
  
  public Boolean superOpenClasses(final RuleApplicationTrace _trace_, final OpenClass openClass, final List<OpenClass> existing) throws RuleFailedException {
    try {
    	return superOpenClassesInternal(_trace_, openClass, existing);
    } catch (Exception _e_superOpenClasses) {
    	throw extractRuleFailedException(_e_superOpenClasses);
    }
  }
  
  public Boolean superNewClasses(final NewClass openClass, final List<NewClass> existing) throws RuleFailedException {
    return superNewClasses(null, openClass, existing);
  }
  
  public Boolean superNewClasses(final RuleApplicationTrace _trace_, final NewClass openClass, final List<NewClass> existing) throws RuleFailedException {
    try {
    	return superNewClassesInternal(_trace_, openClass, existing);
    } catch (Exception _e_superNewClasses) {
    	throw extractRuleFailedException(_e_superNewClasses);
    }
  }
  
  public Result<Boolean> noCyclicOpenClassHierarchy(final OpenClass clazz) {
    return noCyclicOpenClassHierarchy(null, clazz);
  }
  
  public Result<Boolean> noCyclicOpenClassHierarchy(final RuleApplicationTrace _trace_, final OpenClass clazz) {
    try {
    	return noCyclicOpenClassHierarchyInternal(_trace_, clazz);
    } catch (Exception _e_NoCyclicOpenClassHierarchy) {
    	return resultForFailure(_e_NoCyclicOpenClassHierarchy);
    }
  }
  
  protected Result<Boolean> noCyclicOpenClassHierarchyInternal(final RuleApplicationTrace _trace_, final OpenClass clazz) throws RuleFailedException {
    final ArrayList<OpenClass> ext = CollectionLiterals.<OpenClass>newArrayList();
    Boolean _superOpenClasses = this.superOpenClassesInternal(_trace_, clazz, ext);
    /* superOpenClasses(clazz, ext) */
    if (!_superOpenClasses) {
      sneakyThrowRuleFailedException("superOpenClasses(clazz, ext)");
    }
    boolean _contains = ext.contains(clazz);
    if (_contains) {
      /* fail error "Cyclic dependency" source clazz feature AlePackage::eINSTANCE.openClass_SuperClass */
      String error = "Cyclic dependency";
      EObject source = clazz;
      EReference _openClass_SuperClass = AlePackage.eINSTANCE.getOpenClass_SuperClass();
      EStructuralFeature feature = _openClass_SuperClass;
      throwForExplicitFail(error, new ErrorInformation(source, feature));
    }
    return new Result<Boolean>(true);
  }
  
  public Result<Boolean> noCyclicNewClassHierarchy(final NewClass clazz) {
    return noCyclicNewClassHierarchy(null, clazz);
  }
  
  public Result<Boolean> noCyclicNewClassHierarchy(final RuleApplicationTrace _trace_, final NewClass clazz) {
    try {
    	return noCyclicNewClassHierarchyInternal(_trace_, clazz);
    } catch (Exception _e_NoCyclicNewClassHierarchy) {
    	return resultForFailure(_e_NoCyclicNewClassHierarchy);
    }
  }
  
  protected Result<Boolean> noCyclicNewClassHierarchyInternal(final RuleApplicationTrace _trace_, final NewClass clazz) throws RuleFailedException {
    final ArrayList<NewClass> ext = CollectionLiterals.<NewClass>newArrayList();
    Boolean _superNewClasses = this.superNewClassesInternal(_trace_, clazz, ext);
    /* superNewClasses(clazz, ext) */
    if (!_superNewClasses) {
      sneakyThrowRuleFailedException("superNewClasses(clazz, ext)");
    }
    boolean _contains = ext.contains(clazz);
    if (_contains) {
      /* fail error "Cyclic dependency" source clazz feature AlePackage::eINSTANCE.newClass_SuperClass */
      String error = "Cyclic dependency";
      EObject source = clazz;
      EReference _newClass_SuperClass = AlePackage.eINSTANCE.getNewClass_SuperClass();
      EStructuralFeature feature = _newClass_SuperClass;
      throwForExplicitFail(error, new ErrorInformation(source, feature));
    }
    return new Result<Boolean>(true);
  }
  
  public Result<Boolean> checkClassNames(final Root root) {
    return checkClassNames(null, root);
  }
  
  public Result<Boolean> checkClassNames(final RuleApplicationTrace _trace_, final Root root) {
    try {
    	return checkClassNamesInternal(_trace_, root);
    } catch (Exception _e_CheckClassNames) {
    	return resultForFailure(_e_CheckClassNames);
    }
  }
  
  protected Result<Boolean> checkClassNamesInternal(final RuleApplicationTrace _trace_, final Root root) throws RuleFailedException {
    EList<ale.xtext.ale.Class> _classes = root.getClasses();
    final Function1<ale.xtext.ale.Class, String> _function = (ale.xtext.ale.Class it) -> {
      return it.getName();
    };
    Map<String, List<ale.xtext.ale.Class>> _groupBy = IterableExtensions.<String, ale.xtext.ale.Class>groupBy(_classes, _function);
    final Function2<String, List<ale.xtext.ale.Class>, Boolean> _function_1 = (String p1, List<ale.xtext.ale.Class> p2) -> {
      int _length = ((Object[])Conversions.unwrapArray(p2, Object.class)).length;
      return Boolean.valueOf((_length > 1));
    };
    Map<String, List<ale.xtext.ale.Class>> _filter = MapExtensions.<String, List<ale.xtext.ale.Class>>filter(_groupBy, _function_1);
    Collection<List<ale.xtext.ale.Class>> _values = _filter.values();
    Iterable<ale.xtext.ale.Class> _flatten = Iterables.<ale.xtext.ale.Class>concat(_values);
    for (final ale.xtext.ale.Class x : _flatten) {
      /* fail error "Duplicated name" source x feature AlePackage::eINSTANCE.class_Name */
      String error = "Duplicated name";
      EObject source = x;
      EAttribute _class_Name = AlePackage.eINSTANCE.getClass_Name();
      EStructuralFeature feature = _class_Name;
      throwForExplicitFail(error, new ErrorInformation(source, feature));
    }
    return new Result<Boolean>(true);
  }
  
  public Result<Boolean> checkFieldName(final ale.xtext.ale.Class clazz) {
    return checkFieldName(null, clazz);
  }
  
  public Result<Boolean> checkFieldName(final RuleApplicationTrace _trace_, final ale.xtext.ale.Class clazz) {
    try {
    	return checkFieldNameInternal(_trace_, clazz);
    } catch (Exception _e_CheckFieldName) {
    	return resultForFailure(_e_CheckFieldName);
    }
  }
  
  protected Result<Boolean> checkFieldNameInternal(final RuleApplicationTrace _trace_, final ale.xtext.ale.Class clazz) throws RuleFailedException {
    EList<Field> _fields = clazz.getFields();
    final Function1<Field, String> _function = (Field it) -> {
      return it.getName();
    };
    Map<String, List<Field>> _groupBy = IterableExtensions.<String, Field>groupBy(_fields, _function);
    final Function2<String, List<Field>, Boolean> _function_1 = (String p1, List<Field> p2) -> {
      int _length = ((Object[])Conversions.unwrapArray(p2, Object.class)).length;
      return Boolean.valueOf((_length > 1));
    };
    Map<String, List<Field>> _filter = MapExtensions.<String, List<Field>>filter(_groupBy, _function_1);
    Collection<List<Field>> _values = _filter.values();
    Iterable<Field> _flatten = Iterables.<Field>concat(_values);
    for (final Field x : _flatten) {
      /* fail error "Duplicated name" source x feature AlePackage::eINSTANCE.field_Name */
      String error = "Duplicated name";
      EObject source = x;
      EAttribute _field_Name = AlePackage.eINSTANCE.getField_Name();
      EStructuralFeature feature = _field_Name;
      throwForExplicitFail(error, new ErrorInformation(source, feature));
    }
    return new Result<Boolean>(true);
  }
  
  protected Boolean superOpenClassesInternal(final RuleApplicationTrace _trace_, final OpenClass openClass, final List<OpenClass> existing) {
    try {
    	checkParamsNotNull(openClass, existing);
    	return superOpenClassesDispatcher.invoke(_trace_, openClass, existing);
    } catch (Exception _e_superOpenClasses) {
    	sneakyThrowRuleFailedException(_e_superOpenClasses);
    	return false;
    }
  }
  
  protected void superOpenClassesThrowException(final String _error, final String _issue, final Exception _ex, final OpenClass openClass, final List<OpenClass> existing, final ErrorInformation[] _errorInformations) throws RuleFailedException {
    throwRuleFailedException(_error, _issue, _ex, _errorInformations);
  }
  
  protected Boolean superNewClassesInternal(final RuleApplicationTrace _trace_, final NewClass openClass, final List<NewClass> existing) {
    try {
    	checkParamsNotNull(openClass, existing);
    	return superNewClassesDispatcher.invoke(_trace_, openClass, existing);
    } catch (Exception _e_superNewClasses) {
    	sneakyThrowRuleFailedException(_e_superNewClasses);
    	return false;
    }
  }
  
  protected void superNewClassesThrowException(final String _error, final String _issue, final Exception _ex, final NewClass openClass, final List<NewClass> existing, final ErrorInformation[] _errorInformations) throws RuleFailedException {
    throwRuleFailedException(_error, _issue, _ex, _errorInformations);
  }
  
  protected Boolean superOpenClassesImpl(final RuleApplicationTrace _trace_, final OpenClass openClass, final List<OpenClass> existing) throws RuleFailedException {
    try {
    	final RuleApplicationTrace _subtrace_ = newTrace(_trace_);
    	final Boolean _result_ = applyAuxFunSuperOpenClasses(_subtrace_, openClass, existing);
    	addToTrace(_trace_, new Provider<Object>() {
    		public Object get() {
    			return auxFunName("superOpenClasses") + "(" + stringRep(openClass) + ", " + stringRep(existing)+ ")" + " = " + stringRep(_result_);
    		}
    	});
    	addAsSubtrace(_trace_, _subtrace_);
    	return _result_;
    } catch (Exception e_applyAuxFunSuperOpenClasses) {
    	superOpenClassesThrowException(auxFunName("superOpenClasses") + "(" + stringRep(openClass) + ", " + stringRep(existing)+ ")",
    		SUPEROPENCLASSES,
    		e_applyAuxFunSuperOpenClasses, openClass, existing, new ErrorInformation[] {new ErrorInformation(openClass)});
    	return false;
    }
  }
  
  protected Boolean applyAuxFunSuperOpenClasses(final RuleApplicationTrace _trace_, final OpenClass openClass, final List<OpenClass> existing) throws RuleFailedException {
    EList<OpenClass> _superClass = openClass.getSuperClass();
    boolean _notEquals = (!Objects.equal(_superClass, null));
    if (_notEquals) {
      EList<OpenClass> _superClass_1 = openClass.getSuperClass();
      for (final OpenClass c : _superClass_1) {
        boolean _contains = existing.contains(c);
        boolean _not = (!_contains);
        if (_not) {
          boolean _add = existing.add(c);
          /* existing.add(c) */
          if (!_add) {
            sneakyThrowRuleFailedException("existing.add(c)");
          }
          /* superOpenClasses(c, existing) */
          if (!this.superOpenClassesInternal(_trace_, c, existing)) {
            sneakyThrowRuleFailedException("superOpenClasses(c, existing)");
          }
        }
      }
    }
    return true;
  }
  
  protected Boolean superNewClassesImpl(final RuleApplicationTrace _trace_, final NewClass newClass, final List<NewClass> existing) throws RuleFailedException {
    try {
    	final RuleApplicationTrace _subtrace_ = newTrace(_trace_);
    	final Boolean _result_ = applyAuxFunSuperNewClasses(_subtrace_, newClass, existing);
    	addToTrace(_trace_, new Provider<Object>() {
    		public Object get() {
    			return auxFunName("superNewClasses") + "(" + stringRep(newClass) + ", " + stringRep(existing)+ ")" + " = " + stringRep(_result_);
    		}
    	});
    	addAsSubtrace(_trace_, _subtrace_);
    	return _result_;
    } catch (Exception e_applyAuxFunSuperNewClasses) {
    	superNewClassesThrowException(auxFunName("superNewClasses") + "(" + stringRep(newClass) + ", " + stringRep(existing)+ ")",
    		SUPERNEWCLASSES,
    		e_applyAuxFunSuperNewClasses, newClass, existing, new ErrorInformation[] {new ErrorInformation(newClass)});
    	return false;
    }
  }
  
  protected Boolean applyAuxFunSuperNewClasses(final RuleApplicationTrace _trace_, final NewClass newClass, final List<NewClass> existing) throws RuleFailedException {
    EList<NewClass> _superClass = newClass.getSuperClass();
    boolean _notEquals = (!Objects.equal(_superClass, null));
    if (_notEquals) {
      EList<NewClass> _superClass_1 = newClass.getSuperClass();
      for (final NewClass c : _superClass_1) {
        boolean _contains = existing.contains(c);
        boolean _not = (!_contains);
        if (_not) {
          boolean _add = existing.add(c);
          /* existing.add(c) */
          if (!_add) {
            sneakyThrowRuleFailedException("existing.add(c)");
          }
          /* superNewClasses(c, existing) */
          if (!this.superNewClassesInternal(_trace_, c, existing)) {
            sneakyThrowRuleFailedException("superNewClasses(c, existing)");
          }
        }
      }
    }
    return true;
  }
}
