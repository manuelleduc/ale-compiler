/*
 * generated by Xtext 2.10.0
 */
package dsl.xtext.generator

import dsl.xtext.dsl.DSL
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dsl.xtext.dsl.Behavior
import dsl.xtext.dsl.Syntax
import org.eclipse.emf.ecore.EPackage
import org.eclipse.emf.ecore.EcorePackage
import org.eclipse.emf.ecore.xmi.impl.XMIResourceFactoryImpl
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl
import java.util.List
import org.eclipse.emf.ecore.EClass
import ale.xtext.ale.Field
import java.util.Map
import org.eclipse.emf.ecore.EcoreFactory
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.EClassifier
import ale.xtext.ale.Type
import org.eclipse.emf.common.util.URI

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class DslGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {

		val dsl = resource.allContents.filter(typeof(DSL)).head
		
		
		val models = dsl.syntaxes.map[loadModel]

		this.generateDynamicModel(dsl, models, fsa)
//		fsa.generateFile('greetings.txt', 'People to greet: ' + 
//			resource.allContents
//				.filter(typeof(Greeting))
//				.map[name]
//				.join(', '))
	}

	def getLoadModel(Syntax syntax) {
		if (!EPackage.Registry.INSTANCE.containsKey(EcorePackage.eNS_URI))
			EPackage.Registry.INSTANCE.put(EcorePackage.eNS_URI, EcorePackage.eINSTANCE)

		Resource.Factory.Registry.INSTANCE.extensionToFactoryMap.put("ecore", new XMIResourceFactoryImpl)

		val rs = new ResourceSetImpl

		rs.packageRegistry.getEPackage(syntax.value)
	}

	def void generateDynamicModel(DSL dsl, List<EPackage> models, IFileSystemAccess2 fsa) {
		dsl.behaviours.forEach[generateDynamicModel(it, models, fsa)]
	}

	def void generateDynamicModel(Behavior behavior, List<EPackage> models) {
		val root = behavior.value
		val behaviorName = root.name

		val Map<EClass, List<Field>> clazzList = newHashMap()

		root.classes.forEach [ extendedClass |
			if (!extendedClass.fields.empty) {
				val fields = extendedClass.fields
				val baseClass = models.map [ m |
					m.eAllContents.filter(typeof(EClass)).filter[c|c.name == extendedClass.name]
				].head.head
				clazzList.put(baseClass, fields)
			}
		]

		val EPackage dynamicModelPackage = EcoreFactory.eINSTANCE.createEPackage
		dynamicModelPackage.setName(behaviorName.replaceAll("\\.", ""))
		dynamicModelPackage.setNsPrefix(behaviorName)
		dynamicModelPackage.setNsURI("http://" + behaviorName)

		clazzList.entrySet.forEach [ entry |
			val EClass fromClazz = entry.key
			val EClass clazz = EcoreFactory.eINSTANCE.createEClass
			clazz.setName(fromClazz.getName())
			clazz.getESuperTypes().add(fromClazz)

			entry.value.forEach [ variableDecl |
				val EReference ref = EcoreFactory.eINSTANCE.createEReference
				ref.setName(variableDecl.getName());
				ref.setEType(variableDecl.getType().toEcoreType);
				clazz.getEStructuralFeatures().add(ref);
			]
			dynamicModelPackage.getEClassifiers().add(clazz);
		];

//		URI createUri = URI.createPlatformResourceURI("/" + projectName + "/src-gen/" + behaviourName + ".ecore",
//				true);
//
//		final Resource resource = resSet.createResource(createUri);
//
//		resource.getContents().add(dynamicModelPackage);
//
//		resource.save(null);
//
//		return dynamicModelPackage;
	}

	private def EClassifier toEcoreType(Type type) {
	}

}
