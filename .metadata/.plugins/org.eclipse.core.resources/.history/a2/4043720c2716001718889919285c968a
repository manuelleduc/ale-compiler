package ale.xtext;

import ale.xtext.ale.Qualfied;
import ale.xtext.ale.Root;
import it.xsemantics.runtime.ErrorInformation;
import it.xsemantics.runtime.Result;
import it.xsemantics.runtime.RuleApplicationTrace;
import it.xsemantics.runtime.RuleEnvironment;
import it.xsemantics.runtime.RuleFailedException;
import it.xsemantics.runtime.XsemanticsRuntimeSystem;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.util.PolymorphicDispatcher;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.Functions.Function2;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.MapExtensions;

@SuppressWarnings("all")
public class AleType extends XsemanticsRuntimeSystem {
  private PolymorphicDispatcher<Result<String>> classTypeDispatcher;
  
  public AleType() {
    init();
  }
  
  public void init() {
    classTypeDispatcher = buildPolymorphicDispatcher1(
    	"classTypeImpl", 3, "|-", ":");
  }
  
  public Result<String> classType(final ale.xtext.ale.Class clazz) {
    return classType(new RuleEnvironment(), null, clazz);
  }
  
  public Result<String> classType(final RuleEnvironment _environment_, final ale.xtext.ale.Class clazz) {
    return classType(_environment_, null, clazz);
  }
  
  public Result<String> classType(final RuleEnvironment _environment_, final RuleApplicationTrace _trace_, final ale.xtext.ale.Class clazz) {
    try {
    	return classTypeInternal(_environment_, _trace_, clazz);
    } catch (Exception _e_classType) {
    	return resultForFailure(_e_classType);
    }
  }
  
  public Result<Boolean> checkClassNames(final Root root) {
    return checkClassNames(null, root);
  }
  
  public Result<Boolean> checkClassNames(final RuleApplicationTrace _trace_, final Root root) {
    try {
    	return checkClassNamesInternal(_trace_, root);
    } catch (Exception _e_CheckClassNames) {
    	return resultForFailure(_e_CheckClassNames);
    }
  }
  
  protected Result<Boolean> checkClassNamesInternal(final RuleApplicationTrace _trace_, final Root root) throws RuleFailedException {
    Qualfied _name = root.getName();
    InputOutput.<Qualfied>println(_name);
    EList<ale.xtext.ale.Class> _classes = root.getClasses();
    final Function1<ale.xtext.ale.Class, String> _function = (ale.xtext.ale.Class it) -> {
      return it.getName();
    };
    Map<String, List<ale.xtext.ale.Class>> _groupBy = IterableExtensions.<String, ale.xtext.ale.Class>groupBy(_classes, _function);
    final Function2<String, List<ale.xtext.ale.Class>, Boolean> _function_1 = (String p1, List<ale.xtext.ale.Class> p2) -> {
      int _length = ((Object[])Conversions.unwrapArray(p2, Object.class)).length;
      return Boolean.valueOf((_length > 1));
    };
    Map<String, List<ale.xtext.ale.Class>> _filter = MapExtensions.<String, List<ale.xtext.ale.Class>>filter(_groupBy, _function_1);
    Set<String> _keySet = _filter.keySet();
    boolean _isEmpty = _keySet.isEmpty();
    boolean _not = (!_isEmpty);
    if (_not) {
      /* fail error "Duplicate names" source root */
      String error = "Duplicate names";
      EObject source = root;
      throwForExplicitFail(error, new ErrorInformation(source, null));
    }
    return new Result<Boolean>(true);
  }
  
  protected Result<String> classTypeInternal(final RuleEnvironment _environment_, final RuleApplicationTrace _trace_, final ale.xtext.ale.Class clazz) {
    try {
    	checkParamsNotNull(clazz);
    	return classTypeDispatcher.invoke(_environment_, _trace_, clazz);
    } catch (Exception _e_classType) {
    	sneakyThrowRuleFailedException(_e_classType);
    	return null;
    }
  }
  
  protected void classTypeThrowException(final String _error, final String _issue, final Exception _ex, final ale.xtext.ale.Class clazz, final ErrorInformation[] _errorInformations) throws RuleFailedException {
    throwRuleFailedException(_error, _issue, _ex, _errorInformations);
  }
}
