import ale.xtext.ale.AlePackage
import ale.xtext.ale.Class
import ale.xtext.ale.DefMethod
import ale.xtext.ale.NewClass
import ale.xtext.ale.OpenClass
import ale.xtext.ale.Root
import java.util.List

system ale.xtext.AleType
//
//judgments {
//	classType |- ale.xtext.ale.Class clazz: output String
//}

auxiliary {
	superClasses(Class openClass, List<OpenClass> existing)
//	superNewClasses(NewClass openClass, List<NewClass> existing)
}


auxiliary superClasses(Class openClass, List<OpenClass> existing) {
	if(openClass.superClass != null) {
		for(c: openClass.superClass) {
			if(!existing.contains(c)) {
				existing.add(c)
				superOpenClasses(c, existing)
			}
		}
	}
}

auxiliary superNewClasses(NewClass newClass, List<NewClass> existing) {
 	if(newClass.superClass != null) {
		for(c: newClass.superClass) {
			if(!existing.contains(c)) {
				existing.add(c)
				superNewClasses(c, existing)
			}
		}
	}
}


checkrule NoCyclicOpenClassHierarchy for
	OpenClass clazz
from {
	val ext = newArrayList()
	superOpenClasses(clazz, ext)
	if(ext.contains(clazz)) {
		fail
			error "Cyclic dependency"
			source clazz
			feature AlePackage::eINSTANCE.openClass_SuperClass
		
	}
}

checkrule defMethodDoesNotAlreadyExists for
	DefMethod method
from {
	(method.eContainer as Class).
}

checkrule NoCyclicNewClassHierarchy for
	NewClass clazz
from {
	val ext = newArrayList()
	superNewClasses(clazz, ext)
	if(ext.contains(clazz)) {
		fail
			error "Cyclic dependency"
			source clazz
			feature AlePackage::eINSTANCE.newClass_SuperClass
	}
}

checkrule CheckClassNames for
	Root root
from {
	for(x: root.classes.groupBy[name].filter[p1, p2| p2.length > 1].values.flatten) {
		fail
			error "Duplicated name"
			source x
			feature AlePackage::eINSTANCE.class_Name
	}
}


// TODO: take in account imported classes once available
checkrule CheckFieldName for
	Class clazz
from {
	for(x: clazz.fields.groupBy[name].filter[p1, p2|p2.length>1].values.flatten) {
		fail
			error "Duplicated name"
			source x
			feature AlePackage::eINSTANCE.field_Name
	}
}