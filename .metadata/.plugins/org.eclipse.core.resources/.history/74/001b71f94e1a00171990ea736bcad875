package ale.compiler;

import java.io.FileWriter;
import java.io.IOException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import org.eclipse.core.resources.IProject;
import org.eclipse.core.runtime.IPath;
import org.eclipse.emf.codegen.ecore.generator.Generator;
import org.eclipse.emf.codegen.ecore.generator.GeneratorAdapterFactory;
import org.eclipse.emf.codegen.ecore.genmodel.GenJDKLevel;
import org.eclipse.emf.codegen.ecore.genmodel.GenModel;
import org.eclipse.emf.codegen.ecore.genmodel.GenModelFactory;
import org.eclipse.emf.codegen.ecore.genmodel.generator.GenBaseGeneratorAdapter;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EDataType;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EcoreFactory;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;
import org.eclipse.emf.ecore.xmi.impl.XMIResourceFactoryImpl;
import org.eclipse.xtext.resource.XtextResource;
import org.eclipse.xtext.resource.XtextResourceSet;

import com.google.inject.Injector;

import ale.xtext.AleStandaloneSetup;
import ale.xtext.ale.AleFactory;
import ale.xtext.ale.Class;
import ale.xtext.ale.Field;
import ale.xtext.ale.OpenClass;
import ale.xtext.ale.Root;
import ale.xtext.ale.Type;
import dsl.xtext.DslStandaloneSetup;
import dsl.xtext.dsl.Behavior;
import dsl.xtext.dsl.DSL;
import dsl.xtext.dsl.Syntax;
import fr.inria.diverse.objectalgebragenerator.GenerateAlgebra;
import fr.inria.diverse.objectalgebragenerator.Graph;
import fr.inria.diverse.objectalgebragenerator.Graph.GraphNode;

/**
 * 
 * This compiler compiles a given semantic, which conform itself to a bunch of
 * syntaxes, to a bunch of (conforming) target syntaxes.
 * 
 * @author mleduc
 *
 */
public class AleCompiler {

	private final java.net.URI dslURI;
	private Root root;
	private List<EPackage> syntaxes;
	private List<EPackage> models;

	public AleCompiler(final java.net.URI uri) {
		this.dslURI = uri;
	}

	private GenModel saveGenModel(final ResourceSetImpl resSet, final String languageName, final EPackage rootPackage,
			final String projectName) {
		/*
		 * Final step: Generating the emf code from the ecore generated
		 */

		Resource.Factory.Registry.INSTANCE.getExtensionToFactoryMap().put("genmodel", new XMIResourceFactoryImpl());

		// resSet.getURIConverter().getURIMap().putAll(EcorePlugin.computePlatformURIMap(true));

		final GenModel genModel = GenModelFactory.eINSTANCE.createGenModel();
		genModel.setComplianceLevel(GenJDKLevel.JDK80_LITERAL);
		genModel.getForeignModel().add("http://" + languageName);
		genModel.setModelName("MODELNAMETEST");
		genModel.setModelPluginID("ModelPluginIDTest");
		genModel.getForeignModel().add(rootPackage.getNsURI());
		genModel.initialize(Collections.singleton(rootPackage));
		genModel.setModelDirectory("/" + projectName + "/src");

		// TODO: Update genmodel in order to avoid the regeneration of
		// cross-references

		final URI createURI = URI
				.createPlatformResourceURI("/" + projectName + "/src-gen/" + languageName + ".genmodel", true);
		final Resource res = resSet.createResource(createURI);

		res.getContents().add(genModel);

		try {
			res.save(null);

		} catch (final IOException e) {
			e.printStackTrace();
		}

		return genModel;
	}

	private void proceedToGeneration(final GenModel genModel) {
		genModel.reconcile();
		genModel.setCanGenerate(true);
		genModel.setValidateModel(true);
		genModel.setUpdateClasspath(true);

		final org.eclipse.emf.codegen.ecore.generator.GeneratorAdapterFactory.Descriptor.Registry reg = GeneratorAdapterFactory.Descriptor.Registry.INSTANCE;
		final Generator generator = new Generator(reg);
		generator.setInput(genModel);

		generator.generate(genModel, GenBaseGeneratorAdapter.MODEL_PROJECT_TYPE, new NullMonitorImplementation(this));

	}

	private EPackage load(final Syntax stx, final ResourceSet rs) {
		if (!EPackage.Registry.INSTANCE.containsKey(EcorePackage.eNS_URI))
			EPackage.Registry.INSTANCE.put(EcorePackage.eNS_URI, EcorePackage.eINSTANCE);

		Resource.Factory.Registry.INSTANCE.getExtensionToFactoryMap().put("ecore", new XMIResourceFactoryImpl());

		return rs.getPackageRegistry().getEPackage(stx.getValue().replaceAll("\"", ""));
	}

	public void compile(final IProject project) throws IOException {

		Resource.Factory.Registry.INSTANCE.getExtensionToFactoryMap().put("dsl", new XMIResourceFactoryImpl());
		Resource.Factory.Registry.INSTANCE.getExtensionToFactoryMap().put("ale", new XMIResourceFactoryImpl());
		final ResourceSetImpl resSet = new ResourceSetImpl();

		final com.google.inject.Injector injector = new DslStandaloneSetup().createInjectorAndDoEMFRegistration();

		final XtextResourceSet resourceSet = injector.getInstance(XtextResourceSet.class);
		resourceSet.addLoadOption(XtextResource.OPTION_RESOLVE_ALL, Boolean.TRUE);

		final Resource resource = resourceSet.getResource(URI.createURI(this.dslURI.toString()), true);
		final DSL model = (DSL) resource.getContents().get(0);

		this.syntaxes = model.getSyntaxes().stream().map((final Syntax stx) -> load(stx, resSet))
				.collect(Collectors.toList());

		final EList<Behavior> behaviors = model.getBehaviours();
		this.models = model.getSyntaxes().stream().map(syntax -> {
			if (!EPackage.Registry.INSTANCE.containsKey(EcorePackage.eNS_URI))
				EPackage.Registry.INSTANCE.put(EcorePackage.eNS_URI, EcorePackage.eINSTANCE);
			Resource.Factory.Registry.INSTANCE.getExtensionToFactoryMap().put("ecore", new XMIResourceFactoryImpl());
			return resSet.getPackageRegistry().getEPackage(syntax.getValue());
		}).collect(Collectors.toList());

		for (final Behavior behavior : behaviors) {

			final String projectName = "test";
			// EcoreUtil2.resolveAll(behavior);
			final Root root = convertBehviorToRoot(resourceSet, behavior);
			final EPackage rootPackage = this.generateDynamicModel(projectName, resSet, root);
			final GenModel genModel = this.saveGenModel(resSet, root.getName(), rootPackage, projectName);
			this.proceedToGeneration(genModel);

			this.syntaxes.forEach(ePackage -> {
				this.generateAlgebra(ePackage, project);
			});

			this.generateAlgebra(rootPackage, project);

			final List<EClass> listAllClasses = new GenerateAlgebra().getListAllClasses(rootPackage);
			listAllClasses.forEach(clazz -> {
				final Class behaviorClass = behaviors.stream().map(b -> convertBehviorToRoot(resourceSet, b))
						.flatMap(b -> b.getClasses().stream()).filter(b -> b.getName().equals(clazz.getName()))
						.findFirst().orElse(null);
				// if (behaviorClass == null) {
				// OpenClass openCls = AleFactory.eINSTANCE.createOpenClass();

				// new GenerateOperation().generate(clazz, project, openCls);
				// }
				// else
				if (behaviorClass instanceof OpenClass)
					new GenerateOperation().generate(clazz, project, (OpenClass) behaviorClass);
			});

			this.generateConcreteAlgebra(rootPackage, project);

			this.generateConcreteOperations(rootPackage, behavior, project);
		}

	}

	private Root convertBehviorToRoot(final XtextResourceSet resourceSet, final Behavior behavior) {
		final Injector injector2 = new AleStandaloneSetup().createInjectorAndDoEMFRegistration();
		final XtextResourceSet resourceSet2 = injector2.getInstance(XtextResourceSet.class);
		resourceSet2.addLoadOption(XtextResource.OPTION_RESOLVE_ALL, Boolean.TRUE);

		final String value = behavior.getValue();
		// URI eProxyURI = ((org.eclipse.emf.ecore.InternalEObject)
		// value).eProxyURI();
		// Resource resourceValue = resourceSet.getResource(eProxyURI,
		// true);
		// value = (Root) resourceValue.getContents().get(0);

		final URI createURI = URI.createURI(value);
		final Resource resource2 = resourceSet.getResource(createURI, true);
		final Root root = (Root) resource2.getContents().get(0);
		return root;
	}

	private void generateConcreteOperations(final EPackage rootPackage, final Behavior behavior,
			final IProject project) {
		final Graph<EClass> res = new GenerateAlgebra().buildGraph(rootPackage);
		res.nodes.forEach(entry -> {
			generateConceteOperation(entry, project, rootPackage);
		});

	}

	private void generateConceteOperation(final GraphNode<EClass> entry, final IProject project,
			final EPackage ePackage) {
		final String fileContent = new GenerateAlgebra().processConcreteOperation(entry, ePackage);
		final IPath directoryAlgebra = project.getLocation().append("src").append(ePackage.getName()).append("algebra")
				.append("impl").append("operation");
		directoryAlgebra.toFile().mkdirs();

		final EClass rootType = entry.elem;
		final String ePackageName = rootType.getEPackage().getName().substring(0, 1).toUpperCase()
				+ rootType.getEPackage().getName().substring(1);
		final String rootTypeName = rootType.getName().substring(0, 1).toUpperCase() + rootType.getName().substring(1);
		// String typeName = entry.getValue()
		final IPath fileJavaAlgebra = directoryAlgebra.append(ePackageName + rootTypeName + "Operation")
				.addFileExtension("java");

		try {
			final FileWriter fileWriter = new FileWriter(fileJavaAlgebra.toFile());
			fileWriter.write(fileContent);
			fileWriter.close();
		} catch (final IOException e) {
			e.printStackTrace();
		}
	}

	private void generateConcreteAlgebra(final EPackage ePackage, final IProject project) {
		final String fileContent = new GenerateAlgebra().processConcreteAlgebra(ePackage);
		final IPath directoryAlgebra = project.getLocation().append("src").append(ePackage.getName()).append("algebra")
				.append("impl");
		directoryAlgebra.toFile().mkdirs();
		final IPath fileJavaAlgebra = directoryAlgebra.append(
				ePackage.getName().substring(0, 1).toUpperCase() + ePackage.getName().substring(1) + "AlgebraImpl")
				.addFileExtension("java");

		try {
			final FileWriter fileWriter = new FileWriter(fileJavaAlgebra.toFile());
			fileWriter.write(fileContent);
			fileWriter.close();
		} catch (final IOException e) {
			e.printStackTrace();
		}

	}

	/**
	 * Generates a ecore file from the dynamic data declared in the implemented
	 * behavior
	 * 
	 * @param projectName
	 * @param resSet
	 * @return
	 * 
	 * @throws IOException
	 */
	private EPackage generateDynamicModel(final String projectName, final ResourceSet resSet, final Root modelBehavior)
			throws IOException {
		final String behaviourName = modelBehavior.getName();
		final Map<ale.xtext.ale.Class, List<Field>> clazzList = new HashMap<>();

		final List<ale.xtext.ale.Class> classExtensions = modelBehavior.getClasses();
		classExtensions.forEach(extendedClass -> {
			if (!extendedClass.getFields().isEmpty()) {
				final List<Field> attributes = extendedClass.getFields();
				clazzList.put(extendedClass, attributes);
			}
		});

		final EPackage dynamicModelPackage = EcoreFactory.eINSTANCE.createEPackage();
		dynamicModelPackage.setName(behaviourName.replaceAll("\\.", ""));
		dynamicModelPackage.setNsPrefix(behaviourName);
		dynamicModelPackage.setNsURI("http://" + behaviourName);

		clazzList.entrySet().stream().forEach(entry -> {
			final ale.xtext.ale.Class fromClazz = entry.getKey();
			final EClass clazz = EcoreFactory.eINSTANCE.createEClass();
			clazz.setName(fromClazz.getName());
			final EClass superClazz = this.getClassFromName(fromClazz.getName());

			clazz.getESuperTypes().add(superClazz);

			entry.getValue().stream().forEach(variableDecl -> {
				final EClassifier resolveType = resolveType(variableDecl.getType());
				if (resolveType instanceof EDataType) {

					final EAttribute createEAttribute = EcoreFactory.eINSTANCE.createEAttribute();
					createEAttribute.setName(variableDecl.getName());
					createEAttribute.setEType(resolveType);
					clazz.getEAttributes().add(createEAttribute);
				} else {
					final EReference ref = EcoreFactory.eINSTANCE.createEReference();
					ref.setName(variableDecl.getName());
					ref.setEType(resolveType);
					// ref.setEGenericType(variableDecl.getType().getEGenericType());
					// // attr.setE
					//
					// // TODO : solve why currentState has an error in modeling
					// // workbench
					//
					clazz.getEReferences().add(ref);

				}
			});

			dynamicModelPackage.getEClassifiers().add(clazz);
		});

		final URI createUri = URI.createPlatformResourceURI("/" + projectName + "/src-gen/" + behaviourName + ".ecore",
				true);

		final Resource resource = resSet.createResource(createUri);

		resource.getContents().add(dynamicModelPackage);

		resource.save(null);

		return dynamicModelPackage;

	}

	private EClassifier resolveType(final Type type) {
		return EcorePackage.eINSTANCE.getEString();
	}

	private EClass getClassFromName(final String name) {
		for (final EPackage packagz : this.models) {

			final EClassifier pack = packagz.getEClassifier(name);
			if (pack != null && pack instanceof EClass) {
				return (EClass) pack;
			}
		}
		return null;

	}

	private void generateAlgebra(final EPackage ePackage, final IProject project) {
		final String fileContent = new GenerateAlgebra().processAlgebra(ePackage);
		final IPath directoryAlgebra = project.getLocation().append("src").append(ePackage.getName()).append("algebra");
		directoryAlgebra.toFile().mkdirs();
		final IPath fileJavaAlgebra = directoryAlgebra
				.append(ePackage.getName().substring(0, 1).toUpperCase() + ePackage.getName().substring(1) + "Algebra")
				.addFileExtension("java");

		try {
			final FileWriter fileWriter = new FileWriter(fileJavaAlgebra.toFile());
			fileWriter.write(fileContent);
			fileWriter.close();
		} catch (final IOException e) {
			e.printStackTrace();
		}
	}

}
